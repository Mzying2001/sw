<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimpleWindow: sw::UIElement类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SimpleWindow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsw_1_1UIElement.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-attribs">Public 属性</a> &#124;
<a href="#pro-methods">Protected 成员函数</a> &#124;
<a href="classsw_1_1UIElement-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">sw::UIElement类 参考<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>表示界面中的元素  
 <a href="classsw_1_1UIElement.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="UIElement_8h_source.html">UIElement.h</a>&gt;</code></p>
<div class="dynheader">
类 sw::UIElement 继承关系图:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsw_1_1UIElement.png" usemap="#sw::UIElement_map" alt=""/>
  <map id="sw::UIElement_map" name="sw::UIElement_map">
<area href="classsw_1_1WndBase.html" title="表示一个Windows窗口，是所有窗口和控件的基类" alt="sw::WndBase" shape="rect" coords="235,56,460,80"/>
<area href="classsw_1_1ILayout.html" title="布局接口" alt="sw::ILayout" shape="rect" coords="470,56,695,80"/>
<area href="classsw_1_1ITag.html" title="Tag接口" alt="sw::ITag" shape="rect" coords="705,56,930,80"/>
<area href="classsw_1_1DynamicObject.html" title="动态对象基类" alt="sw::DynamicObject" shape="rect" coords="0,0,225,24"/>
<area href="classsw_1_1IToString.html" alt="sw::IToString&lt; WndBase &gt;" shape="rect" coords="235,0,460,24"/>
<area href="classsw_1_1IEqualityComparable.html" alt="sw::IEqualityComparable&lt; WndBase &gt;" shape="rect" coords="470,0,695,24"/>
<area href="classsw_1_1Control.html" title="控件" alt="sw::Control" shape="rect" coords="235,168,460,192"/>
<area href="classsw_1_1HwndWrapper.html" title="将Win32 window包装为SimpleWindow对象" alt="sw::HwndWrapper" shape="rect" coords="470,168,695,192"/>
<area href="classsw_1_1Layer.html" title="表示可以设置布局方式的元素类型，如窗口、面板等" alt="sw::Layer" shape="rect" coords="705,168,930,192"/>
<area href="classsw_1_1ItemsControl.html" alt="sw::ItemsControl&lt; StrList &gt;" shape="rect" coords="470,224,695,248"/>
<area href="classsw_1_1ItemsControl.html" alt="sw::ItemsControl&lt; TreeViewNode &gt;" shape="rect" coords="470,280,695,304"/>
<area href="classsw_1_1Animation.html" title="动画控件，仅支持无音频的avi动画" alt="sw::Animation" shape="rect" coords="470,336,695,360"/>
<area href="classsw_1_1ButtonBase.html" title="窗口类名为BUTTON的控件类型的基类" alt="sw::ButtonBase" shape="rect" coords="470,392,695,416"/>
<area href="classsw_1_1DateTimePicker.html" title="日期和时间选取器" alt="sw::DateTimePicker" shape="rect" coords="470,448,695,472"/>
<area href="classsw_1_1HotKeyControl.html" title="热键框" alt="sw::HotKeyControl" shape="rect" coords="470,504,695,528"/>
<area href="classsw_1_1ItemsControl.html" title="表示可用于呈现一组项的控件" alt="sw::ItemsControl&lt; TItem &gt;" shape="rect" coords="470,560,695,584"/>
<area href="classsw_1_1MonthCalendar.html" title="月历控件" alt="sw::MonthCalendar" shape="rect" coords="470,616,695,640"/>
<area href="classsw_1_1PanelBase.html" title="面板类型的基类" alt="sw::PanelBase" shape="rect" coords="470,672,695,696"/>
<area href="classsw_1_1ProgressBar.html" title="进度条控件" alt="sw::ProgressBar" shape="rect" coords="470,728,695,752"/>
<area href="classsw_1_1Slider.html" title="滑块控件" alt="sw::Slider" shape="rect" coords="470,784,695,808"/>
<area href="classsw_1_1Splitter.html" title="分隔条" alt="sw::Splitter" shape="rect" coords="470,840,695,864"/>
<area href="classsw_1_1StaticControl.html" title="静态控件" alt="sw::StaticControl" shape="rect" coords="470,896,695,920"/>
<area href="classsw_1_1StatusBar.html" title="状态栏" alt="sw::StatusBar" shape="rect" coords="470,952,695,976"/>
<area href="classsw_1_1SysLink.html" title="包含链接的文本区域" alt="sw::SysLink" shape="rect" coords="470,1008,695,1032"/>
<area href="classsw_1_1TabControl.html" title="标签页控件" alt="sw::TabControl" shape="rect" coords="470,1064,695,1088"/>
<area href="classsw_1_1TextBoxBase.html" title="窗口类名为EDIT的控件类型的基类" alt="sw::TextBoxBase" shape="rect" coords="470,1120,695,1144"/>
<area href="classsw_1_1PanelBase.html" title="面板类型的基类" alt="sw::PanelBase" shape="rect" coords="940,224,1165,248"/>
<area href="classsw_1_1Window.html" title="窗口" alt="sw::Window" shape="rect" coords="940,280,1165,304"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsw_1_1UIElement_1_1__CanAddChild_3_01T_00_01decltype_07void_07std_1_1declval_3_01UIElementc4e59a28561b2f6c76501e41deec6964.html">_CanAddChild&lt; T, decltype(void(std::declval&lt; UIElement &gt;().AddChild(std::declval&lt; T &gt;())))&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">_CanAddChild模板偏特化，当AddChild有对应类型的重载时该偏特化生效  <a href="structsw_1_1UIElement_1_1__CanAddChild_3_01T_00_01decltype_07void_07std_1_1declval_3_01UIElementc4e59a28561b2f6c76501e41deec6964.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:aeebf42b059a9962fd9c2ba64dcc309ca" id="r_aeebf42b059a9962fd9c2ba64dcc309ca"><td class="memItemLeft" align="right" valign="top"><a id="aeebf42b059a9962fd9c2ba64dcc309ca" name="aeebf42b059a9962fd9c2ba64dcc309ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UIElement</b> ()</td></tr>
<tr class="memdesc:aeebf42b059a9962fd9c2ba64dcc309ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化UIElement <br /></td></tr>
<tr class="separator:aeebf42b059a9962fd9c2ba64dcc309ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe28513919da89bf3f9a5102d6353c3" id="r_acbe28513919da89bf3f9a5102d6353c3"><td class="memItemLeft" align="right" valign="top"><a id="acbe28513919da89bf3f9a5102d6353c3" name="acbe28513919da89bf3f9a5102d6353c3"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~UIElement</b> ()=0</td></tr>
<tr class="memdesc:acbe28513919da89bf3f9a5102d6353c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">析构函数，这里用纯虚函数使该类成为抽象类 <br /></td></tr>
<tr class="separator:acbe28513919da89bf3f9a5102d6353c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfb72d4ea1966ec455e7805f0931205" id="r_a2cfb72d4ea1966ec455e7805f0931205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a2cfb72d4ea1966ec455e7805f0931205">RegisterRoutedEvent</a> (RoutedEventType eventType, const <a class="el" href="classsw_1_1Delegate.html">RoutedEventHandler</a> &amp;handler)</td></tr>
<tr class="memdesc:a2cfb72d4ea1966ec455e7805f0931205"><td class="mdescLeft">&#160;</td><td class="mdescRight">注册路由事件处理函数，当事件已注册时会覆盖已注册的函数  <br /></td></tr>
<tr class="separator:a2cfb72d4ea1966ec455e7805f0931205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1fb1c05dee9d36a8ecc170aa9ab1be" id="r_a7c1fb1c05dee9d36a8ecc170aa9ab1be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a7c1fb1c05dee9d36a8ecc170aa9ab1be">AddHandler</a> (RoutedEventType eventType, const <a class="el" href="classsw_1_1Delegate.html">RoutedEventHandler</a> &amp;handler)</td></tr>
<tr class="memdesc:a7c1fb1c05dee9d36a8ecc170aa9ab1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加路由事件处理函数  <br /></td></tr>
<tr class="separator:a7c1fb1c05dee9d36a8ecc170aa9ab1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923d78e615a08c39522cbc3655080cd1" id="r_a923d78e615a08c39522cbc3655080cd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a923d78e615a08c39522cbc3655080cd1">RemoveHandler</a> (RoutedEventType eventType, const <a class="el" href="classsw_1_1Delegate.html">RoutedEventHandler</a> &amp;handler)</td></tr>
<tr class="memdesc:a923d78e615a08c39522cbc3655080cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除已添加的路由事件处理函数  <br /></td></tr>
<tr class="separator:a923d78e615a08c39522cbc3655080cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbfb44f8280a3e5e01b71906e588d69" id="r_a0cbfb44f8280a3e5e01b71906e588d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a0cbfb44f8280a3e5e01b71906e588d69">UnregisterRoutedEvent</a> (RoutedEventType eventType)</td></tr>
<tr class="memdesc:a0cbfb44f8280a3e5e01b71906e588d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">取消对应类型路由事件的注册，该函数会移除对应事件所有的处理函数  <br /></td></tr>
<tr class="separator:a0cbfb44f8280a3e5e01b71906e588d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8152f31c5e109ba016316182bcec47" id="r_adf8152f31c5e109ba016316182bcec47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#adf8152f31c5e109ba016316182bcec47">IsRoutedEventRegistered</a> (RoutedEventType eventType)</td></tr>
<tr class="memdesc:adf8152f31c5e109ba016316182bcec47"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断路由事件是否已存在事件处理函数  <br /></td></tr>
<tr class="separator:adf8152f31c5e109ba016316182bcec47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee0000f9edfdce128c7ca3c95ec4ab" id="r_a3dee0000f9edfdce128c7ca3c95ec4ab"><td class="memItemLeft" align="right" valign="top"><a id="a3dee0000f9edfdce128c7ca3c95ec4ab" name="a3dee0000f9edfdce128c7ca3c95ec4ab"></a>
<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (int index) const</td></tr>
<tr class="memdesc:a3dee0000f9edfdce128c7ca3c95ec4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">通过索引获取子元素 <br /></td></tr>
<tr class="separator:a3dee0000f9edfdce128c7ca3c95ec4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4228f4002d366297ece2eb81875f667d" id="r_a4228f4002d366297ece2eb81875f667d"><td class="memItemLeft" align="right" valign="top"><a id="a4228f4002d366297ece2eb81875f667d" name="a4228f4002d366297ece2eb81875f667d"></a>
<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetChildAt</b> (int index) const</td></tr>
<tr class="memdesc:a4228f4002d366297ece2eb81875f667d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取子元素 <br /></td></tr>
<tr class="separator:a4228f4002d366297ece2eb81875f667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32893339be348aa964441954f3a31101" id="r_a32893339be348aa964441954f3a31101"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a32893339be348aa964441954f3a31101">AddChild</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *element)</td></tr>
<tr class="memdesc:a32893339be348aa964441954f3a31101"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加子元素  <br /></td></tr>
<tr class="separator:a32893339be348aa964441954f3a31101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1576ecfeec8347256a1c43a33169e1dc" id="r_a1576ecfeec8347256a1c43a33169e1dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a1576ecfeec8347256a1c43a33169e1dc">AddChild</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;element)</td></tr>
<tr class="memdesc:a1576ecfeec8347256a1c43a33169e1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加子元素  <br /></td></tr>
<tr class="separator:a1576ecfeec8347256a1c43a33169e1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac020bc2d263e0dcffa59e0f474ea6e95" id="r_ac020bc2d263e0dcffa59e0f474ea6e95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ac020bc2d263e0dcffa59e0f474ea6e95">AddChild</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *element, uint64_t layoutTag)</td></tr>
<tr class="memdesc:ac020bc2d263e0dcffa59e0f474ea6e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加子元素并设置布局标记  <br /></td></tr>
<tr class="separator:ac020bc2d263e0dcffa59e0f474ea6e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e08b05c1a3ac1d95fd54a3ffaab81a0" id="r_a3e08b05c1a3ac1d95fd54a3ffaab81a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a3e08b05c1a3ac1d95fd54a3ffaab81a0">AddChild</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;element, uint64_t layoutTag)</td></tr>
<tr class="memdesc:a3e08b05c1a3ac1d95fd54a3ffaab81a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加子元素并设置布局标记  <br /></td></tr>
<tr class="separator:a3e08b05c1a3ac1d95fd54a3ffaab81a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622a68f74b9122c0de9c57e547b0a62b" id="r_a622a68f74b9122c0de9c57e547b0a62b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a622a68f74b9122c0de9c57e547b0a62b">RemoveChildAt</a> (int index)</td></tr>
<tr class="memdesc:a622a68f74b9122c0de9c57e547b0a62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除指定索引处的子元素  <br /></td></tr>
<tr class="separator:a622a68f74b9122c0de9c57e547b0a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925353891b62cb6989410d788a8a4e90" id="r_a925353891b62cb6989410d788a8a4e90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a925353891b62cb6989410d788a8a4e90">RemoveChild</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *element)</td></tr>
<tr class="memdesc:a925353891b62cb6989410d788a8a4e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除子元素  <br /></td></tr>
<tr class="separator:a925353891b62cb6989410d788a8a4e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e825715639370ad2dd1f1276e6cb97f" id="r_a9e825715639370ad2dd1f1276e6cb97f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a9e825715639370ad2dd1f1276e6cb97f">RemoveChild</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;element)</td></tr>
<tr class="memdesc:a9e825715639370ad2dd1f1276e6cb97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除子元素  <br /></td></tr>
<tr class="separator:a9e825715639370ad2dd1f1276e6cb97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9585aee58045291cdca577e64f4a56e3" id="r_a9585aee58045291cdca577e64f4a56e3"><td class="memItemLeft" align="right" valign="top"><a id="a9585aee58045291cdca577e64f4a56e3" name="a9585aee58045291cdca577e64f4a56e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearChildren</b> ()</td></tr>
<tr class="memdesc:a9585aee58045291cdca577e64f4a56e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除所有子元素 <br /></td></tr>
<tr class="separator:a9585aee58045291cdca577e64f4a56e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cf2817669c10b59535acf8406a1a09" id="r_a45cf2817669c10b59535acf8406a1a09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a45cf2817669c10b59535acf8406a1a09">IndexOf</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *element)</td></tr>
<tr class="memdesc:a45cf2817669c10b59535acf8406a1a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定元素的索引  <br /></td></tr>
<tr class="separator:a45cf2817669c10b59535acf8406a1a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff6722c909efcb10fbbc63476ab64d6" id="r_a8ff6722c909efcb10fbbc63476ab64d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a8ff6722c909efcb10fbbc63476ab64d6">IndexOf</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;element)</td></tr>
<tr class="memdesc:a8ff6722c909efcb10fbbc63476ab64d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定元素的索引  <br /></td></tr>
<tr class="separator:a8ff6722c909efcb10fbbc63476ab64d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf5a64206d296adf153e4d48db9e4ed" id="r_a6cf5a64206d296adf153e4d48db9e4ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a6cf5a64206d296adf153e4d48db9e4ed">ShowContextMenu</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;point, sw::HorizontalAlignment horz=sw::HorizontalAlignment::Left, sw::VerticalAlignment vert=sw::VerticalAlignment::Top)</td></tr>
<tr class="memdesc:a6cf5a64206d296adf153e4d48db9e4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">弹出当前元素的上下文菜单  <br /></td></tr>
<tr class="separator:a6cf5a64206d296adf153e4d48db9e4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce4a26101de27550375c300b121d95d" id="r_abce4a26101de27550375c300b121d95d"><td class="memItemLeft" align="right" valign="top"><a id="abce4a26101de27550375c300b121d95d" name="abce4a26101de27550375c300b121d95d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MoveToTop</b> ()</td></tr>
<tr class="memdesc:abce4a26101de27550375c300b121d95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动到界面顶部 <br /></td></tr>
<tr class="separator:abce4a26101de27550375c300b121d95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793adc7d50d0373d099b26b0a511b95d" id="r_a793adc7d50d0373d099b26b0a511b95d"><td class="memItemLeft" align="right" valign="top"><a id="a793adc7d50d0373d099b26b0a511b95d" name="a793adc7d50d0373d099b26b0a511b95d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MoveToBottom</b> ()</td></tr>
<tr class="memdesc:a793adc7d50d0373d099b26b0a511b95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">移动到界面底部 <br /></td></tr>
<tr class="separator:a793adc7d50d0373d099b26b0a511b95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e5c298d836a9b89d750cdacfbacc56" id="r_a89e5c298d836a9b89d750cdacfbacc56"><td class="memItemLeft" align="right" valign="top"><a id="a89e5c298d836a9b89d750cdacfbacc56" name="a89e5c298d836a9b89d750cdacfbacc56"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRootElement</b> () const</td></tr>
<tr class="memdesc:a89e5c298d836a9b89d750cdacfbacc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断当前元素是否为根节点 <br /></td></tr>
<tr class="separator:a89e5c298d836a9b89d750cdacfbacc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560ae73ce93ab62df8d04170b11a1f39" id="r_a560ae73ce93ab62df8d04170b11a1f39"><td class="memItemLeft" align="right" valign="top"><a id="a560ae73ce93ab62df8d04170b11a1f39" name="a560ae73ce93ab62df8d04170b11a1f39"></a>
<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetRootElement</b> ()</td></tr>
<tr class="memdesc:a560ae73ce93ab62df8d04170b11a1f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前元素所在界面树的根节点 <br /></td></tr>
<tr class="separator:a560ae73ce93ab62df8d04170b11a1f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a50134522985f88bb0db352b2be689" id="r_a06a50134522985f88bb0db352b2be689"><td class="memItemLeft" align="right" valign="top"><a id="a06a50134522985f88bb0db352b2be689" name="a06a50134522985f88bb0db352b2be689"></a>
<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetNextElement</b> ()</td></tr>
<tr class="memdesc:a06a50134522985f88bb0db352b2be689"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前元素在界面树上的下一个节点，若已是最后一个节点则返回根节点 <br /></td></tr>
<tr class="separator:a06a50134522985f88bb0db352b2be689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18842f570bdc6f9cebc1a981eb9fe34d" id="r_a18842f570bdc6f9cebc1a981eb9fe34d"><td class="memItemLeft" align="right" valign="top"><a id="a18842f570bdc6f9cebc1a981eb9fe34d" name="a18842f570bdc6f9cebc1a981eb9fe34d"></a>
<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetPreviousElement</b> ()</td></tr>
<tr class="memdesc:a18842f570bdc6f9cebc1a981eb9fe34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前元素在界面树上的上一个节点，若元素为第一个节点则返回最后一个节点 <br /></td></tr>
<tr class="separator:a18842f570bdc6f9cebc1a981eb9fe34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6968c7b711722677fb0b9dd7f5f80442" id="r_a6968c7b711722677fb0b9dd7f5f80442"><td class="memItemLeft" align="right" valign="top"><a id="a6968c7b711722677fb0b9dd7f5f80442" name="a6968c7b711722677fb0b9dd7f5f80442"></a>
<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetNextTabStopElement</b> ()</td></tr>
<tr class="memdesc:a6968c7b711722677fb0b9dd7f5f80442"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取下一个TabStop属性为true的元素 <br /></td></tr>
<tr class="separator:a6968c7b711722677fb0b9dd7f5f80442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11fdaeaf941a3ba35fcc38d3f1d173a" id="r_ab11fdaeaf941a3ba35fcc38d3f1d173a"><td class="memItemLeft" align="right" valign="top"><a id="ab11fdaeaf941a3ba35fcc38d3f1d173a" name="ab11fdaeaf941a3ba35fcc38d3f1d173a"></a>
<a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetPreviousTabStopElement</b> ()</td></tr>
<tr class="memdesc:ab11fdaeaf941a3ba35fcc38d3f1d173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取上一个TabStop属性为true的元素 <br /></td></tr>
<tr class="separator:ab11fdaeaf941a3ba35fcc38d3f1d173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885fcd0ce2feb766f2e3a35ceb8fa8a5" id="r_a885fcd0ce2feb766f2e3a35ceb8fa8a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a885fcd0ce2feb766f2e3a35ceb8fa8a5">GetRealBackColor</a> () const</td></tr>
<tr class="memdesc:a885fcd0ce2feb766f2e3a35ceb8fa8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前要显示的背景颜色  <br /></td></tr>
<tr class="separator:a885fcd0ce2feb766f2e3a35ceb8fa8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f4c0ead1a834d62c5a3e898949c3bd" id="r_a00f4c0ead1a834d62c5a3e898949c3bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a00f4c0ead1a834d62c5a3e898949c3bd">GetRealTextColor</a> () const</td></tr>
<tr class="memdesc:a00f4c0ead1a834d62c5a3e898949c3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前要显示的文本颜色  <br /></td></tr>
<tr class="separator:a00f4c0ead1a834d62c5a3e898949c3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce7edc8a920e950a9a75cf1a84ea627" id="r_a0ce7edc8a920e950a9a75cf1a84ea627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a0ce7edc8a920e950a9a75cf1a84ea627">SetCursor</a> (HCURSOR hCursor)</td></tr>
<tr class="memdesc:a0ce7edc8a920e950a9a75cf1a84ea627"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置鼠标样式  <br /></td></tr>
<tr class="separator:a0ce7edc8a920e950a9a75cf1a84ea627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848d8b2ee3267758e9a784be75b65e46" id="r_a848d8b2ee3267758e9a784be75b65e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a848d8b2ee3267758e9a784be75b65e46">SetCursor</a> (StandardCursor cursor)</td></tr>
<tr class="memdesc:a848d8b2ee3267758e9a784be75b65e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置鼠标样式  <br /></td></tr>
<tr class="separator:a848d8b2ee3267758e9a784be75b65e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421400e98ae700b0593cda2ceec5c1f7" id="r_a421400e98ae700b0593cda2ceec5c1f7"><td class="memItemLeft" align="right" valign="top"><a id="a421400e98ae700b0593cda2ceec5c1f7" name="a421400e98ae700b0593cda2ceec5c1f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetCursor</b> ()</td></tr>
<tr class="memdesc:a421400e98ae700b0593cda2ceec5c1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">将鼠标样式设置为默认样式 <br /></td></tr>
<tr class="separator:a421400e98ae700b0593cda2ceec5c1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2f0c77c7ec5d6d68bc3c772a72201a" id="r_a7b2f0c77c7ec5d6d68bc3c772a72201a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a7b2f0c77c7ec5d6d68bc3c772a72201a">SetAlignment</a> (sw::HorizontalAlignment horz, sw::VerticalAlignment vert)</td></tr>
<tr class="memdesc:a7b2f0c77c7ec5d6d68bc3c772a72201a"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置对齐方式  <br /></td></tr>
<tr class="separator:a7b2f0c77c7ec5d6d68bc3c772a72201a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6442acf30572cc5708fad45d227d130" id="r_aa6442acf30572cc5708fad45d227d130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aa6442acf30572cc5708fad45d227d130">Resize</a> (const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;size)</td></tr>
<tr class="memdesc:aa6442acf30572cc5708fad45d227d130"><td class="mdescLeft">&#160;</td><td class="mdescRight">调整当前元素的尺寸  <br /></td></tr>
<tr class="separator:aa6442acf30572cc5708fad45d227d130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1ce767cc687fa9b9864640cc0237c5" id="r_a9c1ce767cc687fa9b9864640cc0237c5"><td class="memItemLeft" align="right" valign="top"><a id="a9c1ce767cc687fa9b9864640cc0237c5" name="a9c1ce767cc687fa9b9864640cc0237c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsLayoutUpdateConditionSet</b> (sw::LayoutUpdateCondition condition)</td></tr>
<tr class="memdesc:a9c1ce767cc687fa9b9864640cc0237c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断指定的布局更新条件是否已设置 <br /></td></tr>
<tr class="separator:a9c1ce767cc687fa9b9864640cc0237c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea960f1d4f8148b4807d2121f32a6c1" id="r_afea960f1d4f8148b4807d2121f32a6c1"><td class="memItemLeft" align="right" valign="top"><a id="afea960f1d4f8148b4807d2121f32a6c1" name="afea960f1d4f8148b4807d2121f32a6c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InvalidateMeasure</b> ()</td></tr>
<tr class="memdesc:afea960f1d4f8148b4807d2121f32a6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">使元素的布局状态失效，并立即触发布局更新 <br /></td></tr>
<tr class="separator:afea960f1d4f8148b4807d2121f32a6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac916bfc631d0b2a6ff11ceaf624c9e" id="r_adac916bfc631d0b2a6ff11ceaf624c9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#adac916bfc631d0b2a6ff11ceaf624c9e">BringIntoView</a> ()</td></tr>
<tr class="memdesc:adac916bfc631d0b2a6ff11ceaf624c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试将当前元素移动到可视区域内  <br /></td></tr>
<tr class="separator:adac916bfc631d0b2a6ff11ceaf624c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f8d1269f1e70d0d8131a92c5752119" id="r_a04f8d1269f1e70d0d8131a92c5752119"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a04f8d1269f1e70d0d8131a92c5752119">GetTag</a> () const override</td></tr>
<tr class="memdesc:a04f8d1269f1e70d0d8131a92c5752119"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取Tag  <br /></td></tr>
<tr class="separator:a04f8d1269f1e70d0d8131a92c5752119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09acdba6221e69b6ecb17b49975a1414" id="r_a09acdba6221e69b6ecb17b49975a1414"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a09acdba6221e69b6ecb17b49975a1414">SetTag</a> (uint64_t tag) override</td></tr>
<tr class="memdesc:a09acdba6221e69b6ecb17b49975a1414"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置Tag  <br /></td></tr>
<tr class="separator:a09acdba6221e69b6ecb17b49975a1414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a0753061a7821018b4b00a8d58346b" id="r_a86a0753061a7821018b4b00a8d58346b"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a86a0753061a7821018b4b00a8d58346b">GetLayoutTag</a> () const override</td></tr>
<tr class="memdesc:a86a0753061a7821018b4b00a8d58346b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取布局标记  <br /></td></tr>
<tr class="separator:a86a0753061a7821018b4b00a8d58346b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31545a385dc97ead786ecf12a2b1bb2" id="r_ab31545a385dc97ead786ecf12a2b1bb2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ab31545a385dc97ead786ecf12a2b1bb2">GetChildLayoutCount</a> () const override</td></tr>
<tr class="memdesc:ab31545a385dc97ead786ecf12a2b1bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取参与布局的子元素数量  <br /></td></tr>
<tr class="separator:ab31545a385dc97ead786ecf12a2b1bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3683672f3c2fc8f80e4f808aac78d262" id="r_a3683672f3c2fc8f80e4f808aac78d262"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsw_1_1ILayout.html">ILayout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a3683672f3c2fc8f80e4f808aac78d262">GetChildLayoutAt</a> (int index) override</td></tr>
<tr class="memdesc:a3683672f3c2fc8f80e4f808aac78d262"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取对应索引处的子元素，只索引参与布局的子元素  <br /></td></tr>
<tr class="separator:a3683672f3c2fc8f80e4f808aac78d262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55968daf78ca80665ef03f284c72b7ac" id="r_a55968daf78ca80665ef03f284c72b7ac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsw_1_1Size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a55968daf78ca80665ef03f284c72b7ac">GetDesireSize</a> () const override</td></tr>
<tr class="memdesc:a55968daf78ca80665ef03f284c72b7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前元素所需尺寸  <br /></td></tr>
<tr class="separator:a55968daf78ca80665ef03f284c72b7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef217f2655c4a746606bf302edc16cf4" id="r_aef217f2655c4a746606bf302edc16cf4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aef217f2655c4a746606bf302edc16cf4">Measure</a> (const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;availableSize) override</td></tr>
<tr class="memdesc:aef217f2655c4a746606bf302edc16cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">测量元素所需尺寸  <br /></td></tr>
<tr class="separator:aef217f2655c4a746606bf302edc16cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8088cf88b28c6b4a5f93cd7a66a769e" id="r_ac8088cf88b28c6b4a5f93cd7a66a769e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ac8088cf88b28c6b4a5f93cd7a66a769e">Arrange</a> (const <a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &amp;finalPosition) override</td></tr>
<tr class="memdesc:ac8088cf88b28c6b4a5f93cd7a66a769e"><td class="mdescLeft">&#160;</td><td class="mdescRight">安排元素位置  <br /></td></tr>
<tr class="separator:ac8088cf88b28c6b4a5f93cd7a66a769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ab87f8a258e25ae429dab03771b5b4" id="r_a56ab87f8a258e25ae429dab03771b5b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a56ab87f8a258e25ae429dab03771b5b4">ToUIElement</a> () override</td></tr>
<tr class="memdesc:a56ab87f8a258e25ae429dab03771b5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试将对象转换成UIElement  <br /></td></tr>
<tr class="separator:a56ab87f8a258e25ae429dab03771b5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f2c4d1aac620f266c6420c3310ee19" id="r_a98f2c4d1aac620f266c6420c3310ee19"><td class="memTemplParams" colspan="2">template&lt;typename First , typename... Rest&gt; </td></tr>
<tr class="memitem:a98f2c4d1aac620f266c6420c3310ee19"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; _CanAddChildren&lt; First, Rest... &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a98f2c4d1aac620f266c6420c3310ee19">AddChildren</a> (First &amp;&amp;first, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a98f2c4d1aac620f266c6420c3310ee19"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加多个子元素  <br /></td></tr>
<tr class="separator:a98f2c4d1aac620f266c6420c3310ee19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbef9f628b10717ef28fdad71d382499" id="r_abbef9f628b10717ef28fdad71d382499"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbef9f628b10717ef28fdad71d382499"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; _CanAddChild&lt; T &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#abbef9f628b10717ef28fdad71d382499">AddChildren</a> (T &amp;&amp;child)</td></tr>
<tr class="memdesc:abbef9f628b10717ef28fdad71d382499"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加多个子元素  <br /></td></tr>
<tr class="separator:abbef9f628b10717ef28fdad71d382499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09946400c66a4bfd34cfb8918652a34a" id="r_a09946400c66a4bfd34cfb8918652a34a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09946400c66a4bfd34cfb8918652a34a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a09946400c66a4bfd34cfb8918652a34a">RegisterRoutedEvent</a> (RoutedEventType eventType, T &amp;obj, void(T::*handler)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;))</td></tr>
<tr class="memdesc:a09946400c66a4bfd34cfb8918652a34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">注册成员函数作为路由事件处理函数，当事件已注册时会覆盖已注册的函数  <br /></td></tr>
<tr class="separator:a09946400c66a4bfd34cfb8918652a34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9301a84ed462c3c1968b0bc95ed4c9" id="r_a2b9301a84ed462c3c1968b0bc95ed4c9"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs &gt; </td></tr>
<tr class="memitem:a2b9301a84ed462c3c1968b0bc95ed4c9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a2b9301a84ed462c3c1968b0bc95ed4c9">RegisterRoutedEvent</a> (const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;handler)</td></tr>
<tr class="memdesc:a2b9301a84ed462c3c1968b0bc95ed4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据事件参数类型注册路由事件，当事件已注册时会覆盖已注册的函数  <br /></td></tr>
<tr class="separator:a2b9301a84ed462c3c1968b0bc95ed4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da85633be22eec70448cf110914e7de" id="r_a2da85633be22eec70448cf110914e7de"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs , typename THandleObj &gt; </td></tr>
<tr class="memitem:a2da85633be22eec70448cf110914e7de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a2da85633be22eec70448cf110914e7de">RegisterRoutedEvent</a> (THandleObj &amp;obj, void(THandleObj::*handler)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;))</td></tr>
<tr class="memdesc:a2da85633be22eec70448cf110914e7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据事件参数类型注册成员函数作为路由事件，当事件已注册时会覆盖已注册的函数  <br /></td></tr>
<tr class="separator:a2da85633be22eec70448cf110914e7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa714d3978c945ead3d364f719075cd61" id="r_aa714d3978c945ead3d364f719075cd61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa714d3978c945ead3d364f719075cd61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aa714d3978c945ead3d364f719075cd61">AddHandler</a> (RoutedEventType eventType, T &amp;obj, void(T::*handler)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;))</td></tr>
<tr class="memdesc:aa714d3978c945ead3d364f719075cd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加成员函数作为路由事件处理函数  <br /></td></tr>
<tr class="separator:aa714d3978c945ead3d364f719075cd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab825c8749c5bec592e00724f1aa83b" id="r_acab825c8749c5bec592e00724f1aa83b"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs &gt; </td></tr>
<tr class="memitem:acab825c8749c5bec592e00724f1aa83b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#acab825c8749c5bec592e00724f1aa83b">AddHandler</a> (const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;handler)</td></tr>
<tr class="memdesc:acab825c8749c5bec592e00724f1aa83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据事件参数类型添加路由事件处理函数  <br /></td></tr>
<tr class="separator:acab825c8749c5bec592e00724f1aa83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3a2c5888b9e0ef3b45d5f1672d692d" id="r_aab3a2c5888b9e0ef3b45d5f1672d692d"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs , typename THandleObj &gt; </td></tr>
<tr class="memitem:aab3a2c5888b9e0ef3b45d5f1672d692d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aab3a2c5888b9e0ef3b45d5f1672d692d">AddHandler</a> (THandleObj &amp;obj, void(THandleObj::*handler)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;))</td></tr>
<tr class="memdesc:aab3a2c5888b9e0ef3b45d5f1672d692d"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据事件参数类型添加成员函数作为路由事件处理函数  <br /></td></tr>
<tr class="separator:aab3a2c5888b9e0ef3b45d5f1672d692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab5957c173050c3e1d9ac1df9e27e7e" id="r_a9ab5957c173050c3e1d9ac1df9e27e7e"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs &gt; </td></tr>
<tr class="memitem:a9ab5957c173050c3e1d9ac1df9e27e7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;!std::is_same&lt; TEventArgs, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &gt;::value &amp;&amp;!<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a9ab5957c173050c3e1d9ac1df9e27e7e">AddHandler</a> (RoutedEventType eventType, const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;handler)</td></tr>
<tr class="memdesc:a9ab5957c173050c3e1d9ac1df9e27e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加路由事件处理函数  <br /></td></tr>
<tr class="separator:a9ab5957c173050c3e1d9ac1df9e27e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2a5e3ad5ef7969547d7d3024ff9ddc" id="r_aef2a5e3ad5ef7969547d7d3024ff9ddc"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs , typename THandleObj &gt; </td></tr>
<tr class="memitem:aef2a5e3ad5ef7969547d7d3024ff9ddc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;!std::is_same&lt; TEventArgs, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &gt;::value &amp;&amp;!<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aef2a5e3ad5ef7969547d7d3024ff9ddc">AddHandler</a> (RoutedEventType eventType, THandleObj &amp;obj, void(THandleObj::*handler)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;))</td></tr>
<tr class="memdesc:aef2a5e3ad5ef7969547d7d3024ff9ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加成员函数作为路由事件处理函数  <br /></td></tr>
<tr class="separator:aef2a5e3ad5ef7969547d7d3024ff9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bea1478f7f4ddbccf55b7a046b87d7e" id="r_a6bea1478f7f4ddbccf55b7a046b87d7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6bea1478f7f4ddbccf55b7a046b87d7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a6bea1478f7f4ddbccf55b7a046b87d7e">RemoveHandler</a> (RoutedEventType eventType, T &amp;obj, void(T::*handler)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;))</td></tr>
<tr class="memdesc:a6bea1478f7f4ddbccf55b7a046b87d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除已添加的类型为成员函数的路由事件处理函数  <br /></td></tr>
<tr class="separator:a6bea1478f7f4ddbccf55b7a046b87d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff721cb3127445c11f63e9b92ca3b56" id="r_afff721cb3127445c11f63e9b92ca3b56"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs &gt; </td></tr>
<tr class="memitem:afff721cb3127445c11f63e9b92ca3b56"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#afff721cb3127445c11f63e9b92ca3b56">RemoveHandler</a> (const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;handler)</td></tr>
<tr class="memdesc:afff721cb3127445c11f63e9b92ca3b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除已添加的路由事件处理函数  <br /></td></tr>
<tr class="separator:afff721cb3127445c11f63e9b92ca3b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f207de6bae76e8a95c6cc28adef5063" id="r_a6f207de6bae76e8a95c6cc28adef5063"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs , typename THandleObj &gt; </td></tr>
<tr class="memitem:a6f207de6bae76e8a95c6cc28adef5063"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a6f207de6bae76e8a95c6cc28adef5063">RemoveHandler</a> (THandleObj &amp;obj, void(THandleObj::*handler)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;))</td></tr>
<tr class="memdesc:a6f207de6bae76e8a95c6cc28adef5063"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除已添加的类型为成员函数的路由事件处理函数  <br /></td></tr>
<tr class="separator:a6f207de6bae76e8a95c6cc28adef5063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa7e59d71b6371dba12676c4d273025" id="r_affa7e59d71b6371dba12676c4d273025"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs &gt; </td></tr>
<tr class="memitem:affa7e59d71b6371dba12676c4d273025"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;!std::is_same&lt; TEventArgs, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &gt;::value &amp;&amp;!<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#affa7e59d71b6371dba12676c4d273025">RemoveHandler</a> (RoutedEventType eventType, const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;handler)</td></tr>
<tr class="memdesc:affa7e59d71b6371dba12676c4d273025"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除已添加的路由事件处理函数  <br /></td></tr>
<tr class="separator:affa7e59d71b6371dba12676c4d273025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21adb2c61d1f22cd67ea99c025e1be4b" id="r_a21adb2c61d1f22cd67ea99c025e1be4b"><td class="memTemplParams" colspan="2">template&lt;typename TEventArgs , typename THandleObj &gt; </td></tr>
<tr class="memitem:a21adb2c61d1f22cd67ea99c025e1be4b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;!std::is_same&lt; TEventArgs, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &gt;::value &amp;&amp;!<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a21adb2c61d1f22cd67ea99c025e1be4b">RemoveHandler</a> (RoutedEventType eventType, THandleObj &amp;obj, void(THandleObj::*handler)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;))</td></tr>
<tr class="memdesc:a21adb2c61d1f22cd67ea99c025e1be4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除已添加的类型为成员函数的路由事件处理函数  <br /></td></tr>
<tr class="separator:a21adb2c61d1f22cd67ea99c025e1be4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsw_1_1WndBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsw_1_1WndBase')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classsw_1_1WndBase.html">sw::WndBase</a></td></tr>
<tr class="memitem:a6c99714fa3f313e7535936585f63b9cb inherit pub_methods_classsw_1_1WndBase" id="r_a6c99714fa3f313e7535936585f63b9cb"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~WndBase</b> ()=0</td></tr>
<tr class="memdesc:a6c99714fa3f313e7535936585f63b9cb inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">析构函数，这里用纯虚函数使该类成为抽象类 <br /></td></tr>
<tr class="separator:a6c99714fa3f313e7535936585f63b9cb inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4acb69dc4a05fa89dfe8ad9b081eb95 inherit pub_methods_classsw_1_1WndBase" id="r_ae4acb69dc4a05fa89dfe8ad9b081eb95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsw_1_1Control.html">Control</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#ae4acb69dc4a05fa89dfe8ad9b081eb95">ToControl</a> ()</td></tr>
<tr class="memdesc:ae4acb69dc4a05fa89dfe8ad9b081eb95 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试将对象转换成Control  <br /></td></tr>
<tr class="separator:ae4acb69dc4a05fa89dfe8ad9b081eb95 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd7d531ffe1e0219d4d1762180a990d inherit pub_methods_classsw_1_1WndBase" id="r_a2dd7d531ffe1e0219d4d1762180a990d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsw_1_1Window.html">Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a2dd7d531ffe1e0219d4d1762180a990d">ToWindow</a> ()</td></tr>
<tr class="memdesc:a2dd7d531ffe1e0219d4d1762180a990d inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试将对象转换成Window  <br /></td></tr>
<tr class="separator:a2dd7d531ffe1e0219d4d1762180a990d inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1113d1e6b686215fb8f7f5aa5361aa45 inherit pub_methods_classsw_1_1WndBase" id="r_a1113d1e6b686215fb8f7f5aa5361aa45"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (const <a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp;other) const</td></tr>
<tr class="memdesc:a1113d1e6b686215fb8f7f5aa5361aa45 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断当前对象与另一个WndBase是否相等 <br /></td></tr>
<tr class="separator:a1113d1e6b686215fb8f7f5aa5361aa45 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d54d90e20aadd93924df6dc9760fc3 inherit pub_methods_classsw_1_1WndBase" id="r_af4d54d90e20aadd93924df6dc9760fc3"><td class="memItemLeft" align="right" valign="top">
virtual std::wstring&#160;</td><td class="memItemRight" valign="bottom"><b>ToString</b> () const</td></tr>
<tr class="memdesc:af4d54d90e20aadd93924df6dc9760fc3 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前对象的描述字符串 <br /></td></tr>
<tr class="separator:af4d54d90e20aadd93924df6dc9760fc3 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4c84a1f99dc2bc9ac58821f63b7ccf inherit pub_methods_classsw_1_1WndBase" id="r_a8e4c84a1f99dc2bc9ac58821f63b7ccf"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateInternalRect</b> ()</td></tr>
<tr class="memdesc:a8e4c84a1f99dc2bc9ac58821f63b7ccf inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">同步窗口位置和尺寸到内部记录的Rect <br /></td></tr>
<tr class="separator:a8e4c84a1f99dc2bc9ac58821f63b7ccf inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6c13095f64868f94ee846a4ac9abb3 inherit pub_methods_classsw_1_1WndBase" id="r_adf6c13095f64868f94ee846a4ac9abb3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateInternalText</b> ()</td></tr>
<tr class="memdesc:adf6c13095f64868f94ee846a4ac9abb3 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">同步窗口文本到内部记录的字符串 <br /></td></tr>
<tr class="separator:adf6c13095f64868f94ee846a4ac9abb3 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f1b78dd8165c8bca0313180a9f4b81 inherit pub_methods_classsw_1_1WndBase" id="r_ae2f1b78dd8165c8bca0313180a9f4b81"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>Show</b> (int nCmdShow)</td></tr>
<tr class="memdesc:ae2f1b78dd8165c8bca0313180a9f4b81 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">该函数调用ShowWindow <br /></td></tr>
<tr class="separator:ae2f1b78dd8165c8bca0313180a9f4b81 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436818f8ad91446f86b42081dd1a7358 inherit pub_methods_classsw_1_1WndBase" id="r_a436818f8ad91446f86b42081dd1a7358"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>Close</b> ()</td></tr>
<tr class="memdesc:a436818f8ad91446f86b42081dd1a7358 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">发送关闭消息 <br /></td></tr>
<tr class="separator:a436818f8ad91446f86b42081dd1a7358 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ac81f0ed48a5093fd3170c7c756963 inherit pub_methods_classsw_1_1WndBase" id="r_ab7ac81f0ed48a5093fd3170c7c756963"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>Update</b> ()</td></tr>
<tr class="memdesc:ab7ac81f0ed48a5093fd3170c7c756963 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">该函数调用UpdateWindow <br /></td></tr>
<tr class="separator:ab7ac81f0ed48a5093fd3170c7c756963 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8df0384e2be0569e0da1f51985204c8 inherit pub_methods_classsw_1_1WndBase" id="r_af8df0384e2be0569e0da1f51985204c8"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateFont</b> ()</td></tr>
<tr class="memdesc:af8df0384e2be0569e0da1f51985204c8 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">更新字体 <br /></td></tr>
<tr class="separator:af8df0384e2be0569e0da1f51985204c8 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eec178adddff9e44d83238f19d57b1b inherit pub_methods_classsw_1_1WndBase" id="r_a2eec178adddff9e44d83238f19d57b1b"><td class="memItemLeft" align="right" valign="top">
HFONT&#160;</td><td class="memItemRight" valign="bottom"><b>GetFontHandle</b> ()</td></tr>
<tr class="memdesc:a2eec178adddff9e44d83238f19d57b1b inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取字体句柄 <br /></td></tr>
<tr class="separator:a2eec178adddff9e44d83238f19d57b1b inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0e2c8a2900eff9e5a390e251ada042 inherit pub_methods_classsw_1_1WndBase" id="r_a6c0e2c8a2900eff9e5a390e251ada042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a6c0e2c8a2900eff9e5a390e251ada042">Redraw</a> (bool erase=false, bool updateWindow=false)</td></tr>
<tr class="memdesc:a6c0e2c8a2900eff9e5a390e251ada042 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">重画  <br /></td></tr>
<tr class="separator:a6c0e2c8a2900eff9e5a390e251ada042 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93895b2534591c879580a65f2baee1a2 inherit pub_methods_classsw_1_1WndBase" id="r_a93895b2534591c879580a65f2baee1a2"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsVisible</b> () const</td></tr>
<tr class="memdesc:a93895b2534591c879580a65f2baee1a2 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断当前对象在界面中是否可视，与Visible属性不同的是该函数返回值会受父窗口的影响 <br /></td></tr>
<tr class="separator:a93895b2534591c879580a65f2baee1a2 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb99b2215255a3dffcc461032fc649a0 inherit pub_methods_classsw_1_1WndBase" id="r_afb99b2215255a3dffcc461032fc649a0"><td class="memItemLeft" align="right" valign="top">
DWORD&#160;</td><td class="memItemRight" valign="bottom"><b>GetStyle</b> () const</td></tr>
<tr class="memdesc:afb99b2215255a3dffcc461032fc649a0 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取窗口样式 <br /></td></tr>
<tr class="separator:afb99b2215255a3dffcc461032fc649a0 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6dbe392704320ef2e6896eff55dd4f inherit pub_methods_classsw_1_1WndBase" id="r_afc6dbe392704320ef2e6896eff55dd4f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetStyle</b> (DWORD style)</td></tr>
<tr class="memdesc:afc6dbe392704320ef2e6896eff55dd4f inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置窗口样式 <br /></td></tr>
<tr class="separator:afc6dbe392704320ef2e6896eff55dd4f inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba657385186f66f5568d2220b07f3140 inherit pub_methods_classsw_1_1WndBase" id="r_aba657385186f66f5568d2220b07f3140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#aba657385186f66f5568d2220b07f3140">GetStyle</a> (DWORD mask) const</td></tr>
<tr class="memdesc:aba657385186f66f5568d2220b07f3140 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断窗口是否设有指定样式  <br /></td></tr>
<tr class="separator:aba657385186f66f5568d2220b07f3140 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a1c2216b75bd9cd45d4a2e042b55c5 inherit pub_methods_classsw_1_1WndBase" id="r_a34a1c2216b75bd9cd45d4a2e042b55c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a34a1c2216b75bd9cd45d4a2e042b55c5">SetStyle</a> (DWORD mask, bool value)</td></tr>
<tr class="memdesc:a34a1c2216b75bd9cd45d4a2e042b55c5 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">打开或关闭指定的样式  <br /></td></tr>
<tr class="separator:a34a1c2216b75bd9cd45d4a2e042b55c5 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41b1feb33af8c88097f96b1511e4db8 inherit pub_methods_classsw_1_1WndBase" id="r_ac41b1feb33af8c88097f96b1511e4db8"><td class="memItemLeft" align="right" valign="top">
DWORD&#160;</td><td class="memItemRight" valign="bottom"><b>GetExtendedStyle</b> () const</td></tr>
<tr class="memdesc:ac41b1feb33af8c88097f96b1511e4db8 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取扩展窗口样式 <br /></td></tr>
<tr class="separator:ac41b1feb33af8c88097f96b1511e4db8 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074171e62cdb3e20f53b9262164852ca inherit pub_methods_classsw_1_1WndBase" id="r_a074171e62cdb3e20f53b9262164852ca"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetExtendedStyle</b> (DWORD style)</td></tr>
<tr class="memdesc:a074171e62cdb3e20f53b9262164852ca inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置扩展窗口样式 <br /></td></tr>
<tr class="separator:a074171e62cdb3e20f53b9262164852ca inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3e7d32b7cdcfd3489c0d890a2910ab inherit pub_methods_classsw_1_1WndBase" id="r_a2d3e7d32b7cdcfd3489c0d890a2910ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a2d3e7d32b7cdcfd3489c0d890a2910ab">GetExtendedStyle</a> (DWORD mask)</td></tr>
<tr class="memdesc:a2d3e7d32b7cdcfd3489c0d890a2910ab inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断窗口是否设有指定扩展样式  <br /></td></tr>
<tr class="separator:a2d3e7d32b7cdcfd3489c0d890a2910ab inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05caaf7da3138fe9063f7a3e1088f9ac inherit pub_methods_classsw_1_1WndBase" id="r_a05caaf7da3138fe9063f7a3e1088f9ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a05caaf7da3138fe9063f7a3e1088f9ac">SetExtendedStyle</a> (DWORD mask, bool value)</td></tr>
<tr class="memdesc:a05caaf7da3138fe9063f7a3e1088f9ac inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">打开或关闭指定的扩展样式  <br /></td></tr>
<tr class="separator:a05caaf7da3138fe9063f7a3e1088f9ac inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb522b29fd021790209ea52e1393042 inherit pub_methods_classsw_1_1WndBase" id="r_a2cb522b29fd021790209ea52e1393042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw_1_1Point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a2cb522b29fd021790209ea52e1393042">PointToScreen</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="memdesc:a2cb522b29fd021790209ea52e1393042 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取用户区点在屏幕上点的位置  <br /></td></tr>
<tr class="separator:a2cb522b29fd021790209ea52e1393042 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d71fb0f2e544ce991e9934d2169dac inherit pub_methods_classsw_1_1WndBase" id="r_a46d71fb0f2e544ce991e9934d2169dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsw_1_1Point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a46d71fb0f2e544ce991e9934d2169dac">PointFromScreen</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;screenPoint) const</td></tr>
<tr class="memdesc:a46d71fb0f2e544ce991e9934d2169dac inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取屏幕上点在当前用户区点的位置  <br /></td></tr>
<tr class="separator:a46d71fb0f2e544ce991e9934d2169dac inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d23326907c603a24385f81e179e174 inherit pub_methods_classsw_1_1WndBase" id="r_a33d23326907c603a24385f81e179e174"><td class="memItemLeft" align="right" valign="top">
LRESULT&#160;</td><td class="memItemRight" valign="bottom"><b>SendMessageA</b> (UINT uMsg, WPARAM wParam, LPARAM lParam)</td></tr>
<tr class="memdesc:a33d23326907c603a24385f81e179e174 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">发送消息（ASCII） <br /></td></tr>
<tr class="separator:a33d23326907c603a24385f81e179e174 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50166a8ade9a7eaf0088f13fd708e2f inherit pub_methods_classsw_1_1WndBase" id="r_ad50166a8ade9a7eaf0088f13fd708e2f"><td class="memItemLeft" align="right" valign="top">
LRESULT&#160;</td><td class="memItemRight" valign="bottom"><b>SendMessageW</b> (UINT uMsg, WPARAM wParam, LPARAM lParam)</td></tr>
<tr class="memdesc:ad50166a8ade9a7eaf0088f13fd708e2f inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">发送消息（UNICODE） <br /></td></tr>
<tr class="separator:ad50166a8ade9a7eaf0088f13fd708e2f inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a37ba388e9d85339ffc749d427c541f inherit pub_methods_classsw_1_1WndBase" id="r_a4a37ba388e9d85339ffc749d427c541f"><td class="memItemLeft" align="right" valign="top">
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>PostMessageA</b> (UINT uMsg, WPARAM wParam, LPARAM lParam)</td></tr>
<tr class="memdesc:a4a37ba388e9d85339ffc749d427c541f inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">发送消息（ASCII）并立即返回 <br /></td></tr>
<tr class="separator:a4a37ba388e9d85339ffc749d427c541f inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73c2839e2380db3c59a3dbe068937d5 inherit pub_methods_classsw_1_1WndBase" id="r_ae73c2839e2380db3c59a3dbe068937d5"><td class="memItemLeft" align="right" valign="top">
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>PostMessageW</b> (UINT uMsg, WPARAM wParam, LPARAM lParam)</td></tr>
<tr class="memdesc:ae73c2839e2380db3c59a3dbe068937d5 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">发送消息（UNICODE）并立即返回 <br /></td></tr>
<tr class="separator:ae73c2839e2380db3c59a3dbe068937d5 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c9d860ba24487f2b61b72987a4bd63 inherit pub_methods_classsw_1_1WndBase" id="r_a87c9d860ba24487f2b61b72987a4bd63"><td class="memItemLeft" align="right" valign="top">HitTestResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a87c9d860ba24487f2b61b72987a4bd63">NcHitTest</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;testPoint)</td></tr>
<tr class="memdesc:a87c9d860ba24487f2b61b72987a4bd63 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">测试指定点在窗口的哪一部分  <br /></td></tr>
<tr class="separator:a87c9d860ba24487f2b61b72987a4bd63 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b34f2680d2d0d12eb8cc72d99a9f15 inherit pub_methods_classsw_1_1WndBase" id="r_a38b34f2680d2d0d12eb8cc72d99a9f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a38b34f2680d2d0d12eb8cc72d99a9f15">Invoke</a> (const <a class="el" href="classsw_1_1Delegate.html">SimpleAction</a> &amp;action)</td></tr>
<tr class="memdesc:a38b34f2680d2d0d12eb8cc72d99a9f15 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">在窗口线程上执行指定委托  <br /></td></tr>
<tr class="separator:a38b34f2680d2d0d12eb8cc72d99a9f15 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fc26366fd25748226d0d01f7ed9411 inherit pub_methods_classsw_1_1WndBase" id="r_a98fc26366fd25748226d0d01f7ed9411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a98fc26366fd25748226d0d01f7ed9411">InvokeAsync</a> (const <a class="el" href="classsw_1_1Delegate.html">SimpleAction</a> &amp;action)</td></tr>
<tr class="memdesc:a98fc26366fd25748226d0d01f7ed9411 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">在窗口线程上执行指定委托，并立即返回  <br /></td></tr>
<tr class="separator:a98fc26366fd25748226d0d01f7ed9411 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9277205508916d62cdffb2d861b94ed4 inherit pub_methods_classsw_1_1WndBase" id="r_a9277205508916d62cdffb2d861b94ed4"><td class="memItemLeft" align="right" valign="top">
DWORD&#160;</td><td class="memItemRight" valign="bottom"><b>GetThreadId</b> () const</td></tr>
<tr class="memdesc:a9277205508916d62cdffb2d861b94ed4 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前窗口所属线程的线程id <br /></td></tr>
<tr class="separator:a9277205508916d62cdffb2d861b94ed4 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381097fff7da9c84e6052889607cec32 inherit pub_methods_classsw_1_1WndBase" id="r_a381097fff7da9c84e6052889607cec32"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckAccess</b> () const</td></tr>
<tr class="memdesc:a381097fff7da9c84e6052889607cec32 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断当前线程是否为窗口所属线程 <br /></td></tr>
<tr class="separator:a381097fff7da9c84e6052889607cec32 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b409a458c45a42afda42e8f0a856be4 inherit pub_methods_classsw_1_1WndBase" id="r_a0b409a458c45a42afda42e8f0a856be4"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckAccess</b> (const <a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp;other) const</td></tr>
<tr class="memdesc:a0b409a458c45a42afda42e8f0a856be4 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断当前对象所属线程是否与另一个WndBase对象所属线程相同 <br /></td></tr>
<tr class="separator:a0b409a458c45a42afda42e8f0a856be4 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6261aff159337c3af12853b32f60bc9a inherit pub_methods_classsw_1_1WndBase" id="r_a6261aff159337c3af12853b32f60bc9a"><td class="memTemplParams" colspan="2">template&lt;typename TDerived , typename TProperty &gt; </td></tr>
<tr class="memitem:a6261aff159337c3af12853b32f60bc9a inherit pub_methods_classsw_1_1WndBase"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a6261aff159337c3af12853b32f60bc9a">GetProperty</a> (TProperty TDerived::*prop) -&gt; typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsw_1_1WndBase.html">WndBase</a>, TDerived &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsReadableProperty.html">_IsReadableProperty</a>&lt; TProperty &gt;::value, typename TProperty::TValue &gt;::type</td></tr>
<tr class="memdesc:a6261aff159337c3af12853b32f60bc9a inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取属性值  <br /></td></tr>
<tr class="separator:a6261aff159337c3af12853b32f60bc9a inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41601f2d0550bff3c184a0779490f782 inherit pub_methods_classsw_1_1WndBase" id="r_a41601f2d0550bff3c184a0779490f782"><td class="memTemplParams" colspan="2">template&lt;typename TDerived , typename TProperty &gt; </td></tr>
<tr class="memitem:a41601f2d0550bff3c184a0779490f782 inherit pub_methods_classsw_1_1WndBase"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a41601f2d0550bff3c184a0779490f782">SetProperty</a> (TProperty TDerived::*prop, const typename TProperty::TValue &amp;value) -&gt; typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classsw_1_1WndBase.html">WndBase</a>, TDerived &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsWritableProperty.html">_IsWritableProperty</a>&lt; TProperty &gt;::value &gt;::type</td></tr>
<tr class="memdesc:a41601f2d0550bff3c184a0779490f782 inherit pub_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置属性值  <br /></td></tr>
<tr class="separator:a41601f2d0550bff3c184a0779490f782 inherit pub_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsw_1_1DynamicObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsw_1_1DynamicObject')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classsw_1_1DynamicObject.html">sw::DynamicObject</a></td></tr>
<tr class="memitem:a17fa896bc9ba4196c6301fb6c452122f inherit pub_methods_classsw_1_1DynamicObject" id="r_a17fa896bc9ba4196c6301fb6c452122f"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~DynamicObject</b> ()=default</td></tr>
<tr class="memdesc:a17fa896bc9ba4196c6301fb6c452122f inherit pub_methods_classsw_1_1DynamicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">析构函数 <br /></td></tr>
<tr class="separator:a17fa896bc9ba4196c6301fb6c452122f inherit pub_methods_classsw_1_1DynamicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af793982c7d4e7bdec3ddb9c584b0f2ed inherit pub_methods_classsw_1_1DynamicObject" id="r_af793982c7d4e7bdec3ddb9c584b0f2ed"><td class="memItemLeft" align="right" valign="top">std::type_index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1DynamicObject.html#af793982c7d4e7bdec3ddb9c584b0f2ed">GetTypeIndex</a> () const</td></tr>
<tr class="memdesc:af793982c7d4e7bdec3ddb9c584b0f2ed inherit pub_methods_classsw_1_1DynamicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取对象的类型索引  <br /></td></tr>
<tr class="separator:af793982c7d4e7bdec3ddb9c584b0f2ed inherit pub_methods_classsw_1_1DynamicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdfc0484d420f36515a295690f13c84 inherit pub_methods_classsw_1_1DynamicObject" id="r_abfdfc0484d420f36515a295690f13c84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfdfc0484d420f36515a295690f13c84 inherit pub_methods_classsw_1_1DynamicObject"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1DynamicObject.html#abfdfc0484d420f36515a295690f13c84">IsType</a> (T **pout=nullptr)</td></tr>
<tr class="memdesc:abfdfc0484d420f36515a295690f13c84 inherit pub_methods_classsw_1_1DynamicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断对象是否为指定类型  <br /></td></tr>
<tr class="separator:abfdfc0484d420f36515a295690f13c84 inherit pub_methods_classsw_1_1DynamicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f17eecfd1e8164c7bb19394a3588ae inherit pub_methods_classsw_1_1DynamicObject" id="r_a98f17eecfd1e8164c7bb19394a3588ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98f17eecfd1e8164c7bb19394a3588ae inherit pub_methods_classsw_1_1DynamicObject"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1DynamicObject.html#a98f17eecfd1e8164c7bb19394a3588ae">IsType</a> (const T **pout=nullptr) const</td></tr>
<tr class="memdesc:a98f17eecfd1e8164c7bb19394a3588ae inherit pub_methods_classsw_1_1DynamicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断对象是否为指定类型  <br /></td></tr>
<tr class="separator:a98f17eecfd1e8164c7bb19394a3588ae inherit pub_methods_classsw_1_1DynamicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b40c4ae31f19d7e9c9bb37d0356c0a0 inherit pub_methods_classsw_1_1DynamicObject" id="r_a4b40c4ae31f19d7e9c9bb37d0356c0a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b40c4ae31f19d7e9c9bb37d0356c0a0 inherit pub_methods_classsw_1_1DynamicObject"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1DynamicObject.html#a4b40c4ae31f19d7e9c9bb37d0356c0a0">DynamicCast</a> ()</td></tr>
<tr class="memdesc:a4b40c4ae31f19d7e9c9bb37d0356c0a0 inherit pub_methods_classsw_1_1DynamicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">将对象动态转换为指定类型的引用  <br /></td></tr>
<tr class="separator:a4b40c4ae31f19d7e9c9bb37d0356c0a0 inherit pub_methods_classsw_1_1DynamicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8736862ffa02002bd43938b779c13f7 inherit pub_methods_classsw_1_1DynamicObject" id="r_ab8736862ffa02002bd43938b779c13f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8736862ffa02002bd43938b779c13f7 inherit pub_methods_classsw_1_1DynamicObject"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsw_1_1DynamicObject.html#ab8736862ffa02002bd43938b779c13f7">DynamicCast</a> () const</td></tr>
<tr class="memdesc:ab8736862ffa02002bd43938b779c13f7 inherit pub_methods_classsw_1_1DynamicObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">将对象动态转换为指定类型的常量引用  <br /></td></tr>
<tr class="separator:ab8736862ffa02002bd43938b779c13f7 inherit pub_methods_classsw_1_1DynamicObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsw_1_1IToString"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsw_1_1IToString')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classsw_1_1IToString.html">sw::IToString&lt; WndBase &gt;</a></td></tr>
<tr class="memitem:a45c3e793bc1ea212ac7721224fb174e1 inherit pub_methods_classsw_1_1IToString" id="r_a45c3e793bc1ea212ac7721224fb174e1"><td class="memItemLeft" align="right" valign="top">
std::wstring&#160;</td><td class="memItemRight" valign="bottom"><b>ToString</b> () const</td></tr>
<tr class="memdesc:a45c3e793bc1ea212ac7721224fb174e1 inherit pub_methods_classsw_1_1IToString"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取描述当前对象的字符串 <br /></td></tr>
<tr class="separator:a45c3e793bc1ea212ac7721224fb174e1 inherit pub_methods_classsw_1_1IToString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsw_1_1IEqualityComparable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsw_1_1IEqualityComparable')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classsw_1_1IEqualityComparable.html">sw::IEqualityComparable&lt; WndBase &gt;</a></td></tr>
<tr class="memitem:ad5594e770d276411d1213942cb49bb43 inherit pub_methods_classsw_1_1IEqualityComparable" id="r_ad5594e770d276411d1213942cb49bb43"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Equals</b> (const <a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp; other) const</td></tr>
<tr class="memdesc:ad5594e770d276411d1213942cb49bb43 inherit pub_methods_classsw_1_1IEqualityComparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断当前对象与另一个对象是否相等 <br /></td></tr>
<tr class="separator:ad5594e770d276411d1213942cb49bb43 inherit pub_methods_classsw_1_1IEqualityComparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8a939486c99051632b21e3eafa94fd inherit pub_methods_classsw_1_1IEqualityComparable" id="r_a6e8a939486c99051632b21e3eafa94fd"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp; other) const</td></tr>
<tr class="memdesc:a6e8a939486c99051632b21e3eafa94fd inherit pub_methods_classsw_1_1IEqualityComparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断当前对象是否与另一个对象相等 <br /></td></tr>
<tr class="separator:a6e8a939486c99051632b21e3eafa94fd inherit pub_methods_classsw_1_1IEqualityComparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74a5b44827655cda2d573d2d052cccc inherit pub_methods_classsw_1_1IEqualityComparable" id="r_ab74a5b44827655cda2d573d2d052cccc"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp; other) const</td></tr>
<tr class="memdesc:ab74a5b44827655cda2d573d2d052cccc inherit pub_methods_classsw_1_1IEqualityComparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断当前对象是否与另一个对象不相等 <br /></td></tr>
<tr class="separator:ab74a5b44827655cda2d573d2d052cccc inherit pub_methods_classsw_1_1IEqualityComparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsw_1_1ILayout"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsw_1_1ILayout')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classsw_1_1ILayout.html">sw::ILayout</a></td></tr>
<tr class="memitem:a42941ab943edee8c07a7b1da6c7ea226 inherit pub_methods_classsw_1_1ILayout" id="r_a42941ab943edee8c07a7b1da6c7ea226"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ILayout</b> ()=default</td></tr>
<tr class="memdesc:a42941ab943edee8c07a7b1da6c7ea226 inherit pub_methods_classsw_1_1ILayout"><td class="mdescLeft">&#160;</td><td class="mdescRight">默认虚析构函数 <br /></td></tr>
<tr class="separator:a42941ab943edee8c07a7b1da6c7ea226 inherit pub_methods_classsw_1_1ILayout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsw_1_1ITag"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsw_1_1ITag')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classsw_1_1ITag.html">sw::ITag</a></td></tr>
<tr class="memitem:a34c7ead6ffeda8323221f5b85529a771 inherit pub_methods_classsw_1_1ITag" id="r_a34c7ead6ffeda8323221f5b85529a771"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ITag</b> ()=default</td></tr>
<tr class="memdesc:a34c7ead6ffeda8323221f5b85529a771 inherit pub_methods_classsw_1_1ITag"><td class="mdescLeft">&#160;</td><td class="mdescRight">默认虚析构函数 <br /></td></tr>
<tr class="separator:a34c7ead6ffeda8323221f5b85529a771 inherit pub_methods_classsw_1_1ITag"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public 属性</h2></td></tr>
<tr class="memitem:a8fe2c0aebc77409d3fbdefbd79d45a1e" id="r_a8fe2c0aebc77409d3fbdefbd79d45a1e"><td class="memItemLeft" align="right" valign="top"><a id="a8fe2c0aebc77409d3fbdefbd79d45a1e" name="a8fe2c0aebc77409d3fbdefbd79d45a1e"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; <a class="el" href="structsw_1_1Thickness.html">Thickness</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Margin</b></td></tr>
<tr class="memdesc:a8fe2c0aebc77409d3fbdefbd79d45a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">边距 <br /></td></tr>
<tr class="separator:a8fe2c0aebc77409d3fbdefbd79d45a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b569383791dce14d9d6789e3a43d85" id="r_a05b569383791dce14d9d6789e3a43d85"><td class="memItemLeft" align="right" valign="top"><a id="a05b569383791dce14d9d6789e3a43d85" name="a05b569383791dce14d9d6789e3a43d85"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; HorizontalAlignment &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HorizontalAlignment</b></td></tr>
<tr class="memdesc:a05b569383791dce14d9d6789e3a43d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">水平对齐方式 <br /></td></tr>
<tr class="separator:a05b569383791dce14d9d6789e3a43d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f49244beb6b854b436e8bbd18f4e21" id="r_ad9f49244beb6b854b436e8bbd18f4e21"><td class="memItemLeft" align="right" valign="top"><a id="ad9f49244beb6b854b436e8bbd18f4e21" name="ad9f49244beb6b854b436e8bbd18f4e21"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; VerticalAlignment &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>VerticalAlignment</b></td></tr>
<tr class="memdesc:ad9f49244beb6b854b436e8bbd18f4e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">垂直对齐方式 <br /></td></tr>
<tr class="separator:ad9f49244beb6b854b436e8bbd18f4e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c452519bad920ad9b91f9610ea202e0" id="r_a5c452519bad920ad9b91f9610ea202e0"><td class="memItemLeft" align="right" valign="top"><a id="a5c452519bad920ad9b91f9610ea202e0" name="a5c452519bad920ad9b91f9610ea202e0"></a>
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ChildCount</b></td></tr>
<tr class="memdesc:a5c452519bad920ad9b91f9610ea202e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">子元素数量 <br /></td></tr>
<tr class="separator:a5c452519bad920ad9b91f9610ea202e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e87aef0f2dfdec6bd98e944b6d891" id="r_a952e87aef0f2dfdec6bd98e944b6d891"><td class="memItemLeft" align="right" valign="top"><a id="a952e87aef0f2dfdec6bd98e944b6d891" name="a952e87aef0f2dfdec6bd98e944b6d891"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CollapseWhenHide</b></td></tr>
<tr class="memdesc:a952e87aef0f2dfdec6bd98e944b6d891"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否在不可见时不参与布局 <br /></td></tr>
<tr class="separator:a952e87aef0f2dfdec6bd98e944b6d891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad825a0e12b75238b13f422f47ddf292b" id="r_ad825a0e12b75238b13f422f47ddf292b"><td class="memItemLeft" align="right" valign="top"><a id="ad825a0e12b75238b13f422f47ddf292b" name="ad825a0e12b75238b13f422f47ddf292b"></a>
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Parent</b></td></tr>
<tr class="memdesc:ad825a0e12b75238b13f422f47ddf292b"><td class="mdescLeft">&#160;</td><td class="mdescRight">指向父元素的指针，当前元素为顶级窗口时该值为nullptr <br /></td></tr>
<tr class="separator:ad825a0e12b75238b13f422f47ddf292b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895d79a2fa53382a43b3d02dee195360" id="r_a895d79a2fa53382a43b3d02dee195360"><td class="memItemLeft" align="right" valign="top"><a id="a895d79a2fa53382a43b3d02dee195360" name="a895d79a2fa53382a43b3d02dee195360"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Tag</b></td></tr>
<tr class="memdesc:a895d79a2fa53382a43b3d02dee195360"><td class="mdescLeft">&#160;</td><td class="mdescRight">储存用户自定义信息的标记 <br /></td></tr>
<tr class="separator:a895d79a2fa53382a43b3d02dee195360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e870fcabb76b1d74c06d50637f4f92" id="r_a70e870fcabb76b1d74c06d50637f4f92"><td class="memItemLeft" align="right" valign="top"><a id="a70e870fcabb76b1d74c06d50637f4f92" name="a70e870fcabb76b1d74c06d50637f4f92"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LayoutTag</b></td></tr>
<tr class="memdesc:a70e870fcabb76b1d74c06d50637f4f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">布局标记，对于不同的布局有不同含义 <br /></td></tr>
<tr class="separator:a70e870fcabb76b1d74c06d50637f4f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5706cc9d6ef3fab9176ccded231b99e" id="r_ae5706cc9d6ef3fab9176ccded231b99e"><td class="memItemLeft" align="right" valign="top"><a id="ae5706cc9d6ef3fab9176ccded231b99e" name="ae5706cc9d6ef3fab9176ccded231b99e"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; <a class="el" href="classsw_1_1ContextMenu.html">sw::ContextMenu</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ContextMenu</b></td></tr>
<tr class="memdesc:ae5706cc9d6ef3fab9176ccded231b99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">右键按下时弹出的菜单 <br /></td></tr>
<tr class="separator:ae5706cc9d6ef3fab9176ccded231b99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d66604bc2dd555c37688135878a7f0" id="r_ac0d66604bc2dd555c37688135878a7f0"><td class="memItemLeft" align="right" valign="top"><a id="ac0d66604bc2dd555c37688135878a7f0" name="ac0d66604bc2dd555c37688135878a7f0"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Float</b></td></tr>
<tr class="memdesc:ac0d66604bc2dd555c37688135878a7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">元素是否悬浮，若元素悬浮则该元素不会随滚动条滚动而改变位置 <br /></td></tr>
<tr class="separator:ac0d66604bc2dd555c37688135878a7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b54e00e1e41af2a634ad694da3ffa98" id="r_a2b54e00e1e41af2a634ad694da3ffa98"><td class="memItemLeft" align="right" valign="top"><a id="a2b54e00e1e41af2a634ad694da3ffa98" name="a2b54e00e1e41af2a634ad694da3ffa98"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TabStop</b></td></tr>
<tr class="memdesc:a2b54e00e1e41af2a634ad694da3ffa98"><td class="mdescLeft">&#160;</td><td class="mdescRight">表示用户是否可以通过按下Tab键将焦点移动到当前元素 <br /></td></tr>
<tr class="separator:a2b54e00e1e41af2a634ad694da3ffa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6897b58dc2899c37a3b395bfe124b9" id="r_aaf6897b58dc2899c37a3b395bfe124b9"><td class="memItemLeft" align="right" valign="top"><a id="aaf6897b58dc2899c37a3b395bfe124b9" name="aaf6897b58dc2899c37a3b395bfe124b9"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; <a class="el" href="structsw_1_1Color.html">Color</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BackColor</b></td></tr>
<tr class="memdesc:aaf6897b58dc2899c37a3b395bfe124b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">背景颜色，修改该属性会同时将Transparent属性设为false，对于部分控件该属性可能不生效 <br /></td></tr>
<tr class="separator:aaf6897b58dc2899c37a3b395bfe124b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf2381fdffd82bd41e90c1a2cf69022" id="r_aeaf2381fdffd82bd41e90c1a2cf69022"><td class="memItemLeft" align="right" valign="top"><a id="aeaf2381fdffd82bd41e90c1a2cf69022" name="aeaf2381fdffd82bd41e90c1a2cf69022"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; <a class="el" href="structsw_1_1Color.html">Color</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TextColor</b></td></tr>
<tr class="memdesc:aeaf2381fdffd82bd41e90c1a2cf69022"><td class="mdescLeft">&#160;</td><td class="mdescRight">文本颜色，修改该属性会同时将InheritTextColor属性设为false，对于部分控件该属性可能不生效 <br /></td></tr>
<tr class="separator:aeaf2381fdffd82bd41e90c1a2cf69022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d544a538ca2cfa3d022da61e7637e5" id="r_aa9d544a538ca2cfa3d022da61e7637e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aa9d544a538ca2cfa3d022da61e7637e5">Transparent</a></td></tr>
<tr class="memdesc:aa9d544a538ca2cfa3d022da61e7637e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否使用透明背景  <br /></td></tr>
<tr class="separator:aa9d544a538ca2cfa3d022da61e7637e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da2f416b1ed5038d8a3a59d6e44fcf5" id="r_a7da2f416b1ed5038d8a3a59d6e44fcf5"><td class="memItemLeft" align="right" valign="top"><a id="a7da2f416b1ed5038d8a3a59d6e44fcf5" name="a7da2f416b1ed5038d8a3a59d6e44fcf5"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InheritTextColor</b></td></tr>
<tr class="memdesc:a7da2f416b1ed5038d8a3a59d6e44fcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否继承父元素的文本颜色 <br /></td></tr>
<tr class="separator:a7da2f416b1ed5038d8a3a59d6e44fcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ae9ea6fdb1c1ecde418bffdb2287cc" id="r_ab1ae9ea6fdb1c1ecde418bffdb2287cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; sw::LayoutUpdateCondition &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ab1ae9ea6fdb1c1ecde418bffdb2287cc">LayoutUpdateCondition</a></td></tr>
<tr class="memdesc:ab1ae9ea6fdb1c1ecde418bffdb2287cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">触发布局更新的条件  <br /></td></tr>
<tr class="separator:ab1ae9ea6fdb1c1ecde418bffdb2287cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ccd020a37a7da25b9df8eab6783f35" id="r_a78ccd020a37a7da25b9df8eab6783f35"><td class="memItemLeft" align="right" valign="top"><a id="a78ccd020a37a7da25b9df8eab6783f35" name="a78ccd020a37a7da25b9df8eab6783f35"></a>
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IsMeasureValid</b></td></tr>
<tr class="memdesc:a78ccd020a37a7da25b9df8eab6783f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">当前元素的布局状态是否有效 <br /></td></tr>
<tr class="separator:a78ccd020a37a7da25b9df8eab6783f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb629a6497ed371a43572388d0207b" id="r_a99fb629a6497ed371a43572388d0207b"><td class="memItemLeft" align="right" valign="top"><a id="a99fb629a6497ed371a43572388d0207b" name="a99fb629a6497ed371a43572388d0207b"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MinWidth</b></td></tr>
<tr class="memdesc:a99fb629a6497ed371a43572388d0207b"><td class="mdescLeft">&#160;</td><td class="mdescRight">最小宽度，当值为负数或0时表示不限制 <br /></td></tr>
<tr class="separator:a99fb629a6497ed371a43572388d0207b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360ea4cc7f6cf85fef3533f425af97d3" id="r_a360ea4cc7f6cf85fef3533f425af97d3"><td class="memItemLeft" align="right" valign="top"><a id="a360ea4cc7f6cf85fef3533f425af97d3" name="a360ea4cc7f6cf85fef3533f425af97d3"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MinHeight</b></td></tr>
<tr class="memdesc:a360ea4cc7f6cf85fef3533f425af97d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">最小高度，当值为负数或0时表示不限制 <br /></td></tr>
<tr class="separator:a360ea4cc7f6cf85fef3533f425af97d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63be2acaa88ddc21df18ad9f3e08b31" id="r_ad63be2acaa88ddc21df18ad9f3e08b31"><td class="memItemLeft" align="right" valign="top"><a id="ad63be2acaa88ddc21df18ad9f3e08b31" name="ad63be2acaa88ddc21df18ad9f3e08b31"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MaxWidth</b></td></tr>
<tr class="memdesc:ad63be2acaa88ddc21df18ad9f3e08b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">最大宽度，当值为负数或0时表示不限制 <br /></td></tr>
<tr class="separator:ad63be2acaa88ddc21df18ad9f3e08b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97ce0e4104f8c0d9445bc1b8b556b15" id="r_aa97ce0e4104f8c0d9445bc1b8b556b15"><td class="memItemLeft" align="right" valign="top"><a id="aa97ce0e4104f8c0d9445bc1b8b556b15" name="aa97ce0e4104f8c0d9445bc1b8b556b15"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MaxHeight</b></td></tr>
<tr class="memdesc:aa97ce0e4104f8c0d9445bc1b8b556b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">最大高度，当值为负数或0时表示不限制 <br /></td></tr>
<tr class="separator:aa97ce0e4104f8c0d9445bc1b8b556b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb0d213e16e64b9284bcbad8b038ab8" id="r_a5fb0d213e16e64b9284bcbad8b038ab8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; <a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a5fb0d213e16e64b9284bcbad8b038ab8">LogicalRect</a></td></tr>
<tr class="memdesc:a5fb0d213e16e64b9284bcbad8b038ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">元素的逻辑位置和尺寸，即去除布局偏移以及拉伸影响的位置和尺寸  <br /></td></tr>
<tr class="separator:a5fb0d213e16e64b9284bcbad8b038ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87244c08dabca5b114cc1b7040118bc6" id="r_a87244c08dabca5b114cc1b7040118bc6"><td class="memItemLeft" align="right" valign="top"><a id="a87244c08dabca5b114cc1b7040118bc6" name="a87244c08dabca5b114cc1b7040118bc6"></a>
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IsHitTestVisible</b></td></tr>
<tr class="memdesc:a87244c08dabca5b114cc1b7040118bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">当前元素是否响应鼠标事件 <br /></td></tr>
<tr class="separator:a87244c08dabca5b114cc1b7040118bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe46dfe4b73b012c73e57dd8f0ed35c" id="r_a1fe46dfe4b73b012c73e57dd8f0ed35c"><td class="memItemLeft" align="right" valign="top"><a id="a1fe46dfe4b73b012c73e57dd8f0ed35c" name="a1fe46dfe4b73b012c73e57dd8f0ed35c"></a>
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IsFocusedViaTab</b></td></tr>
<tr class="memdesc:a1fe46dfe4b73b012c73e57dd8f0ed35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">当前元素是否是通过按下Tab键获得的焦点 <br /></td></tr>
<tr class="separator:a1fe46dfe4b73b012c73e57dd8f0ed35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classsw_1_1WndBase"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classsw_1_1WndBase')"><img src="closed.png" alt="-"/>&#160;Public 属性 继承自 <a class="el" href="classsw_1_1WndBase.html">sw::WndBase</a></td></tr>
<tr class="memitem:abc0b653ccc071c2cfcba42fa8eef738f inherit pub_attribs_classsw_1_1WndBase" id="r_abc0b653ccc071c2cfcba42fa8eef738f"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; HWND &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Handle</b></td></tr>
<tr class="memdesc:abc0b653ccc071c2cfcba42fa8eef738f inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">窗口句柄 <br /></td></tr>
<tr class="separator:abc0b653ccc071c2cfcba42fa8eef738f inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529436cd730fc39ad2875728cdfe4a51 inherit pub_attribs_classsw_1_1WndBase" id="r_a529436cd730fc39ad2875728cdfe4a51"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; <a class="el" href="classsw_1_1Font.html">sw::Font</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Font</b></td></tr>
<tr class="memdesc:a529436cd730fc39ad2875728cdfe4a51 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">字体 <br /></td></tr>
<tr class="separator:a529436cd730fc39ad2875728cdfe4a51 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a604f374bba1e6c34b5d5e56cd26f0 inherit pub_attribs_classsw_1_1WndBase" id="r_a72a604f374bba1e6c34b5d5e56cd26f0"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FontName</b></td></tr>
<tr class="memdesc:a72a604f374bba1e6c34b5d5e56cd26f0 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">字体名称 <br /></td></tr>
<tr class="separator:a72a604f374bba1e6c34b5d5e56cd26f0 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49c6452ceb4950dd581189615753b0c inherit pub_attribs_classsw_1_1WndBase" id="r_ac49c6452ceb4950dd581189615753b0c"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FontSize</b></td></tr>
<tr class="memdesc:ac49c6452ceb4950dd581189615753b0c inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">字体大小 <br /></td></tr>
<tr class="separator:ac49c6452ceb4950dd581189615753b0c inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e006e69f07abb4e6ba381121abcd22 inherit pub_attribs_classsw_1_1WndBase" id="r_a50e006e69f07abb4e6ba381121abcd22"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; sw::FontWeight &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FontWeight</b></td></tr>
<tr class="memdesc:a50e006e69f07abb4e6ba381121abcd22 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">字体粗细 <br /></td></tr>
<tr class="separator:a50e006e69f07abb4e6ba381121abcd22 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7598603457217f09aae0deaad59ef063 inherit pub_attribs_classsw_1_1WndBase" id="r_a7598603457217f09aae0deaad59ef063"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; <a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Rect</b></td></tr>
<tr class="memdesc:a7598603457217f09aae0deaad59ef063 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">位置和尺寸 <br /></td></tr>
<tr class="separator:a7598603457217f09aae0deaad59ef063 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0b57de9babc053c655872ed91468dd inherit pub_attribs_classsw_1_1WndBase" id="r_a4f0b57de9babc053c655872ed91468dd"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Left</b></td></tr>
<tr class="memdesc:a4f0b57de9babc053c655872ed91468dd inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">左边 <br /></td></tr>
<tr class="separator:a4f0b57de9babc053c655872ed91468dd inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe3776aeb038659f0a290fbe1dc6d7 inherit pub_attribs_classsw_1_1WndBase" id="r_a6dbe3776aeb038659f0a290fbe1dc6d7"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Top</b></td></tr>
<tr class="memdesc:a6dbe3776aeb038659f0a290fbe1dc6d7 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">顶边 <br /></td></tr>
<tr class="separator:a6dbe3776aeb038659f0a290fbe1dc6d7 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445edbe5db50a5a4486ddff98e8ffbae inherit pub_attribs_classsw_1_1WndBase" id="r_a445edbe5db50a5a4486ddff98e8ffbae"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Width</b></td></tr>
<tr class="memdesc:a445edbe5db50a5a4486ddff98e8ffbae inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">宽度 <br /></td></tr>
<tr class="separator:a445edbe5db50a5a4486ddff98e8ffbae inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdc4b943e62bd67ffbff4a6e65de2a inherit pub_attribs_classsw_1_1WndBase" id="r_a51fdc4b943e62bd67ffbff4a6e65de2a"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Height</b></td></tr>
<tr class="memdesc:a51fdc4b943e62bd67ffbff4a6e65de2a inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">高度 <br /></td></tr>
<tr class="separator:a51fdc4b943e62bd67ffbff4a6e65de2a inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0126115c0626d137ba3e7b0a5c8d793b inherit pub_attribs_classsw_1_1WndBase" id="r_a0126115c0626d137ba3e7b0a5c8d793b"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; <a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ClientRect</b></td></tr>
<tr class="memdesc:a0126115c0626d137ba3e7b0a5c8d793b inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户区尺寸 <br /></td></tr>
<tr class="separator:a0126115c0626d137ba3e7b0a5c8d793b inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97898f967c916e67c152c69f4c7c6cd6 inherit pub_attribs_classsw_1_1WndBase" id="r_a97898f967c916e67c152c69f4c7c6cd6"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ClientWidth</b></td></tr>
<tr class="memdesc:a97898f967c916e67c152c69f4c7c6cd6 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户区宽度 <br /></td></tr>
<tr class="separator:a97898f967c916e67c152c69f4c7c6cd6 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4030b80afd9e81e3046ccd5ec94ec83f inherit pub_attribs_classsw_1_1WndBase" id="r_a4030b80afd9e81e3046ccd5ec94ec83f"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ClientHeight</b></td></tr>
<tr class="memdesc:a4030b80afd9e81e3046ccd5ec94ec83f inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户区高度 <br /></td></tr>
<tr class="separator:a4030b80afd9e81e3046ccd5ec94ec83f inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e7d8d1a548315b3e709151f71766b3 inherit pub_attribs_classsw_1_1WndBase" id="r_ad5e7d8d1a548315b3e709151f71766b3"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Enabled</b></td></tr>
<tr class="memdesc:ad5e7d8d1a548315b3e709151f71766b3 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">窗口或控件是否可用 <br /></td></tr>
<tr class="separator:ad5e7d8d1a548315b3e709151f71766b3 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808f5d6fd407e3b65cff88f1873bd754 inherit pub_attribs_classsw_1_1WndBase" id="r_a808f5d6fd407e3b65cff88f1873bd754"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Visible</b></td></tr>
<tr class="memdesc:a808f5d6fd407e3b65cff88f1873bd754 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">窗口或控件是否可见 <br /></td></tr>
<tr class="separator:a808f5d6fd407e3b65cff88f1873bd754 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afff86d32e9b54cccc204ef29a85891 inherit pub_attribs_classsw_1_1WndBase" id="r_a9afff86d32e9b54cccc204ef29a85891"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Text</b></td></tr>
<tr class="memdesc:a9afff86d32e9b54cccc204ef29a85891 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">窗口标题或控件文本 <br /></td></tr>
<tr class="separator:a9afff86d32e9b54cccc204ef29a85891 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71498b3ad8ae548fd7f4a531a6b70982 inherit pub_attribs_classsw_1_1WndBase" id="r_a71498b3ad8ae548fd7f4a531a6b70982"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Focused</b></td></tr>
<tr class="memdesc:a71498b3ad8ae548fd7f4a531a6b70982 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">窗口是否拥有焦点 <br /></td></tr>
<tr class="separator:a71498b3ad8ae548fd7f4a531a6b70982 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda583e7535a89b8b5bd327c1f32ccd inherit pub_attribs_classsw_1_1WndBase" id="r_a7bda583e7535a89b8b5bd327c1f32ccd"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; <a class="el" href="classsw_1_1WndBase.html">WndBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Parent</b></td></tr>
<tr class="memdesc:a7bda583e7535a89b8b5bd327c1f32ccd inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">父窗口 <br /></td></tr>
<tr class="separator:a7bda583e7535a89b8b5bd327c1f32ccd inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54aa973b24b4bc4b681ac2c21a50d204 inherit pub_attribs_classsw_1_1WndBase" id="r_a54aa973b24b4bc4b681ac2c21a50d204"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IsDestroyed</b></td></tr>
<tr class="memdesc:a54aa973b24b4bc4b681ac2c21a50d204 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否已销毁，当该值为true时不应该继续使用当前对象 <br /></td></tr>
<tr class="separator:a54aa973b24b4bc4b681ac2c21a50d204 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b324f78290554d0c08bf6f33cdb5fd inherit pub_attribs_classsw_1_1WndBase" id="r_a43b324f78290554d0c08bf6f33cdb5fd"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AcceptFiles</b></td></tr>
<tr class="memdesc:a43b324f78290554d0c08bf6f33cdb5fd inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否接受拖放文件 <br /></td></tr>
<tr class="separator:a43b324f78290554d0c08bf6f33cdb5fd inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b72c64e192b49d1ace945e96c2368ab inherit pub_attribs_classsw_1_1WndBase" id="r_a4b72c64e192b49d1ace945e96c2368ab"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IsControl</b></td></tr>
<tr class="memdesc:a4b72c64e192b49d1ace945e96c2368ab inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">当前对象是否是控件 <br /></td></tr>
<tr class="separator:a4b72c64e192b49d1ace945e96c2368ab inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39da72806797078fa2ea1a62ada465fc inherit pub_attribs_classsw_1_1WndBase" id="r_a39da72806797078fa2ea1a62ada465fc"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; std::wstring &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ClassName</b></td></tr>
<tr class="memdesc:a39da72806797078fa2ea1a62ada465fc inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">窗口类名 <br /></td></tr>
<tr class="separator:a39da72806797078fa2ea1a62ada465fc inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6dcf5b1b40bd1aed39d6db9a58e377 inherit pub_attribs_classsw_1_1WndBase" id="r_a5e6dcf5b1b40bd1aed39d6db9a58e377"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsw_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a5e6dcf5b1b40bd1aed39d6db9a58e377">IsGroupStart</a></td></tr>
<tr class="memdesc:a5e6dcf5b1b40bd1aed39d6db9a58e377 inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">窗口是否为一组控件中的第一个控件  <br /></td></tr>
<tr class="separator:a5e6dcf5b1b40bd1aed39d6db9a58e377 inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6519a02519ba71182d53eb063b2b01cf inherit pub_attribs_classsw_1_1WndBase" id="r_a6519a02519ba71182d53eb063b2b01cf"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IsMouseCaptured</b></td></tr>
<tr class="memdesc:a6519a02519ba71182d53eb063b2b01cf inherit pub_attribs_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">鼠标是否被当前窗口捕获 <br /></td></tr>
<tr class="separator:a6519a02519ba71182d53eb063b2b01cf inherit pub_attribs_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected 成员函数</h2></td></tr>
<tr class="memitem:a0635558e1928f1144566a30b884303aa" id="r_a0635558e1928f1144566a30b884303aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a0635558e1928f1144566a30b884303aa">RaiseRoutedEvent</a> (RoutedEventType eventType)</td></tr>
<tr class="memdesc:a0635558e1928f1144566a30b884303aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">触发路由事件  <br /></td></tr>
<tr class="separator:a0635558e1928f1144566a30b884303aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135d4fc74c3bf7a434271620944b9f9b" id="r_a135d4fc74c3bf7a434271620944b9f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a135d4fc74c3bf7a434271620944b9f9b">RaiseRoutedEvent</a> (<a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;eventArgs)</td></tr>
<tr class="memdesc:a135d4fc74c3bf7a434271620944b9f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">触发路由事件  <br /></td></tr>
<tr class="separator:a135d4fc74c3bf7a434271620944b9f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05f0f344fb485c8d450350fb72ce3d7" id="r_ac05f0f344fb485c8d450350fb72ce3d7"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ac05f0f344fb485c8d450350fb72ce3d7">GetInternalArrangeOffsetX</a> ()</td></tr>
<tr class="memdesc:ac05f0f344fb485c8d450350fb72ce3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取布局时子元素的水平偏移量  <br /></td></tr>
<tr class="separator:ac05f0f344fb485c8d450350fb72ce3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0da875e8e26fe9a01b74cd8fc321bb" id="r_a2f0da875e8e26fe9a01b74cd8fc321bb"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a2f0da875e8e26fe9a01b74cd8fc321bb">GetInternalArrangeOffsetY</a> ()</td></tr>
<tr class="memdesc:a2f0da875e8e26fe9a01b74cd8fc321bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取布局时子元素的垂直偏移量  <br /></td></tr>
<tr class="separator:a2f0da875e8e26fe9a01b74cd8fc321bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0bde7d9646b68dfe7251eba908cc08" id="r_a1f0bde7d9646b68dfe7251eba908cc08"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a1f0bde7d9646b68dfe7251eba908cc08">GetChildRightmost</a> (bool update)</td></tr>
<tr class="memdesc:a1f0bde7d9646b68dfe7251eba908cc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取所有子元素在当前元素中最右边的位置（只考虑参与布局的子窗口且忽略悬浮的元素）  <br /></td></tr>
<tr class="separator:a1f0bde7d9646b68dfe7251eba908cc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda5652549fe9909e3b6b1383754b30" id="r_a7bda5652549fe9909e3b6b1383754b30"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a7bda5652549fe9909e3b6b1383754b30">GetChildBottommost</a> (bool update)</td></tr>
<tr class="memdesc:a7bda5652549fe9909e3b6b1383754b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取所有子元素在当前元素中最底边的位置（只考虑参与布局的子窗口且忽略悬浮的元素）  <br /></td></tr>
<tr class="separator:a7bda5652549fe9909e3b6b1383754b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33bc2dbdc45763086f61e649aec008e" id="r_aa33bc2dbdc45763086f61e649aec008e"><td class="memItemLeft" align="right" valign="top"><a id="aa33bc2dbdc45763086f61e649aec008e" name="aa33bc2dbdc45763086f61e649aec008e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateChildrenZOrder</b> (bool invalidateMeasure=true)</td></tr>
<tr class="memdesc:aa33bc2dbdc45763086f61e649aec008e"><td class="mdescLeft">&#160;</td><td class="mdescRight">更新子元素的Z轴位置 <br /></td></tr>
<tr class="separator:aa33bc2dbdc45763086f61e649aec008e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c198395a2cd796125b995ea88f968e8" id="r_a1c198395a2cd796125b995ea88f968e8"><td class="memItemLeft" align="right" valign="top"><a id="a1c198395a2cd796125b995ea88f968e8" name="a1c198395a2cd796125b995ea88f968e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateSiblingsZOrder</b> (bool invalidateMeasure=true)</td></tr>
<tr class="memdesc:a1c198395a2cd796125b995ea88f968e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">更新兄弟元素的Z轴位置 <br /></td></tr>
<tr class="separator:a1c198395a2cd796125b995ea88f968e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1f2e03dc38a06d5d8241028ac7ee92" id="r_a5f1f2e03dc38a06d5d8241028ac7ee92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a5f1f2e03dc38a06d5d8241028ac7ee92">ClampDesireSize</a> (<a class="el" href="structsw_1_1Size.html">sw::Size</a> &amp;size) const</td></tr>
<tr class="memdesc:a5f1f2e03dc38a06d5d8241028ac7ee92"><td class="mdescLeft">&#160;</td><td class="mdescRight">限定指定尺寸在最小和最大尺寸之间  <br /></td></tr>
<tr class="separator:a5f1f2e03dc38a06d5d8241028ac7ee92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773d3d44102b709d8e7871ddd83d218e" id="r_a773d3d44102b709d8e7871ddd83d218e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a773d3d44102b709d8e7871ddd83d218e">ClampDesireSize</a> (<a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &amp;rect) const</td></tr>
<tr class="memdesc:a773d3d44102b709d8e7871ddd83d218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">限定指定矩形的尺寸在最小和最大尺寸之间  <br /></td></tr>
<tr class="separator:a773d3d44102b709d8e7871ddd83d218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6121cdf84c8073bae9b3cde98a6a59ea" id="r_a6121cdf84c8073bae9b3cde98a6a59ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a6121cdf84c8073bae9b3cde98a6a59ea">QueryAllChildren</a> (const Func&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> *, bool &gt; &amp;queryFunc)</td></tr>
<tr class="memdesc:a6121cdf84c8073bae9b3cde98a6a59ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">查询所有子元素，直到queryFunc返回false或所有子元素均被查询  <br /></td></tr>
<tr class="separator:a6121cdf84c8073bae9b3cde98a6a59ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd17e0524115089357b146545510fe8" id="r_a8cd17e0524115089357b146545510fe8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsw_1_1Size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a8cd17e0524115089357b146545510fe8">MeasureOverride</a> (const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;availableSize)</td></tr>
<tr class="memdesc:a8cd17e0524115089357b146545510fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">测量元素所需尺寸，无需考虑边框和边距  <br /></td></tr>
<tr class="separator:a8cd17e0524115089357b146545510fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3170826168869b60a1876a3598189a65" id="r_a3170826168869b60a1876a3598189a65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a3170826168869b60a1876a3598189a65">ArrangeOverride</a> (const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;finalSize)</td></tr>
<tr class="memdesc:a3170826168869b60a1876a3598189a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">安排子元素的位置，可重写该函数以实现自定义布局  <br /></td></tr>
<tr class="separator:a3170826168869b60a1876a3598189a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60b45de9f894f4fb152491413f1fa73" id="r_af60b45de9f894f4fb152491413f1fa73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#af60b45de9f894f4fb152491413f1fa73">SetBackColor</a> (<a class="el" href="structsw_1_1Color.html">Color</a> color, bool redraw)</td></tr>
<tr class="memdesc:af60b45de9f894f4fb152491413f1fa73"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置背景颜色  <br /></td></tr>
<tr class="separator:af60b45de9f894f4fb152491413f1fa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8557638ba9975346d62f5339de55664" id="r_ab8557638ba9975346d62f5339de55664"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ab8557638ba9975346d62f5339de55664">SetTextColor</a> (<a class="el" href="structsw_1_1Color.html">Color</a> color, bool redraw)</td></tr>
<tr class="memdesc:ab8557638ba9975346d62f5339de55664"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置文本颜色  <br /></td></tr>
<tr class="separator:ab8557638ba9975346d62f5339de55664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ca4318678de46f4f265f2f98701c1e" id="r_ac5ca4318678de46f4f265f2f98701c1e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ac5ca4318678de46f4f265f2f98701c1e">RequestBringIntoView</a> (const <a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &amp;screenRect)</td></tr>
<tr class="memdesc:ac5ca4318678de46f4f265f2f98701c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">尝试将指定的矩形区域移动到可视区域内  <br /></td></tr>
<tr class="separator:ac5ca4318678de46f4f265f2f98701c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e134d807af7614e1cc812abb860762" id="r_ae3e134d807af7614e1cc812abb860762"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ae3e134d807af7614e1cc812abb860762">OnAddedChild</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;element)</td></tr>
<tr class="memdesc:ae3e134d807af7614e1cc812abb860762"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加子元素后调用该函数  <br /></td></tr>
<tr class="separator:ae3e134d807af7614e1cc812abb860762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadedba1a9bca85555b70bc247b8ef835" id="r_aadedba1a9bca85555b70bc247b8ef835"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aadedba1a9bca85555b70bc247b8ef835">OnRemovedChild</a> (<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;element)</td></tr>
<tr class="memdesc:aadedba1a9bca85555b70bc247b8ef835"><td class="mdescLeft">&#160;</td><td class="mdescRight">移除子元素后调用该函数  <br /></td></tr>
<tr class="separator:aadedba1a9bca85555b70bc247b8ef835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d4134a17b2953346dc9895cd01ce85" id="r_a71d4134a17b2953346dc9895cd01ce85"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a71d4134a17b2953346dc9895cd01ce85">OnTabMove</a> (bool forward)</td></tr>
<tr class="memdesc:a71d4134a17b2953346dc9895cd01ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">通过tab键将焦点从当前元素移出时调用该函数  <br /></td></tr>
<tr class="separator:a71d4134a17b2953346dc9895cd01ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0826e68eb96f7b7dd7882c4c0171b9" id="r_a0f0826e68eb96f7b7dd7882c4c0171b9"><td class="memItemLeft" align="right" valign="top"><a id="a0f0826e68eb96f7b7dd7882c4c0171b9" name="a0f0826e68eb96f7b7dd7882c4c0171b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>OnTabStop</b> ()</td></tr>
<tr class="memdesc:a0f0826e68eb96f7b7dd7882c4c0171b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">通过tab键将焦点移动到当前元素时调用该函数 <br /></td></tr>
<tr class="separator:a0f0826e68eb96f7b7dd7882c4c0171b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a626b2927a2b0ecabfb2dd6d8b47b3" id="r_ae8a626b2927a2b0ecabfb2dd6d8b47b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ae8a626b2927a2b0ecabfb2dd6d8b47b3">OnMinMaxSizeChanged</a> ()</td></tr>
<tr class="memdesc:ae8a626b2927a2b0ecabfb2dd6d8b47b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">当MinWidth、MinHeight、MaxWidth或MaxHeight属性更改时调用此函数  <br /></td></tr>
<tr class="separator:ae8a626b2927a2b0ecabfb2dd6d8b47b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98721f9d3c1069b5afc6188e22145f5d" id="r_a98721f9d3c1069b5afc6188e22145f5d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a98721f9d3c1069b5afc6188e22145f5d">OnRoutedEvent</a> (<a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;eventArgs, const <a class="el" href="classsw_1_1Delegate.html">RoutedEventHandler</a> &amp;handler)</td></tr>
<tr class="memdesc:a98721f9d3c1069b5afc6188e22145f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">路由事件经过当前元素时调用该函数  <br /></td></tr>
<tr class="separator:a98721f9d3c1069b5afc6188e22145f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685138138402ddd8a5fde67bbb85a45" id="r_ad685138138402ddd8a5fde67bbb85a45"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ad685138138402ddd8a5fde67bbb85a45">SetParent</a> (<a class="el" href="classsw_1_1WndBase.html">WndBase</a> *parent) override</td></tr>
<tr class="memdesc:ad685138138402ddd8a5fde67bbb85a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置父窗口  <br /></td></tr>
<tr class="separator:ad685138138402ddd8a5fde67bbb85a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b86762809c8e4a0ace610a977caa78" id="r_a87b86762809c8e4a0ace610a977caa78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a87b86762809c8e4a0ace610a977caa78">ParentChanged</a> (<a class="el" href="classsw_1_1WndBase.html">WndBase</a> *newParent) override</td></tr>
<tr class="memdesc:a87b86762809c8e4a0ace610a977caa78"><td class="mdescLeft">&#160;</td><td class="mdescRight">父窗口改变时调用此函数  <br /></td></tr>
<tr class="separator:a87b86762809c8e4a0ace610a977caa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1f0b6a491e639c76e46a29bff00d65" id="r_a1c1f0b6a491e639c76e46a29bff00d65"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a1c1f0b6a491e639c76e46a29bff00d65">OnClose</a> () override</td></tr>
<tr class="memdesc:a1c1f0b6a491e639c76e46a29bff00d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_CLOSE时调用该函数  <br /></td></tr>
<tr class="separator:a1c1f0b6a491e639c76e46a29bff00d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1708a7be0d9ffdcc18ee89413a7ca55a" id="r_a1708a7be0d9ffdcc18ee89413a7ca55a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a1708a7be0d9ffdcc18ee89413a7ca55a">OnMove</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;newClientPosition) override</td></tr>
<tr class="memdesc:a1708a7be0d9ffdcc18ee89413a7ca55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MOVE时调用该函数  <br /></td></tr>
<tr class="separator:a1708a7be0d9ffdcc18ee89413a7ca55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb5d81280aa50310db09d57145712cd" id="r_a6fb5d81280aa50310db09d57145712cd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a6fb5d81280aa50310db09d57145712cd">OnSize</a> (const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;newClientSize) override</td></tr>
<tr class="memdesc:a6fb5d81280aa50310db09d57145712cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_SIZE时调用该函数  <br /></td></tr>
<tr class="separator:a6fb5d81280aa50310db09d57145712cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1fbc142c7cfe4a4a60959daf0753bc" id="r_a7e1fbc142c7cfe4a4a60959daf0753bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a7e1fbc142c7cfe4a4a60959daf0753bc">OnTextChanged</a> () override</td></tr>
<tr class="memdesc:a7e1fbc142c7cfe4a4a60959daf0753bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Text属性更改时调用此函数  <br /></td></tr>
<tr class="separator:a7e1fbc142c7cfe4a4a60959daf0753bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f7d92c47cd4ec2049f7b669db30ed9" id="r_a89f7d92c47cd4ec2049f7b669db30ed9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a89f7d92c47cd4ec2049f7b669db30ed9">FontChanged</a> (HFONT hfont) override</td></tr>
<tr class="memdesc:a89f7d92c47cd4ec2049f7b669db30ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">字体改变时调用该函数  <br /></td></tr>
<tr class="separator:a89f7d92c47cd4ec2049f7b669db30ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98812949329f77e400f7e0e381c56c3d" id="r_a98812949329f77e400f7e0e381c56c3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a98812949329f77e400f7e0e381c56c3d">VisibleChanged</a> (bool newVisible) override</td></tr>
<tr class="memdesc:a98812949329f77e400f7e0e381c56c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visible属性改变时调用此函数  <br /></td></tr>
<tr class="separator:a98812949329f77e400f7e0e381c56c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c6eb88c9f93bb135da9ee303ada3be" id="r_a95c6eb88c9f93bb135da9ee303ada3be"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a95c6eb88c9f93bb135da9ee303ada3be">OnSetFocus</a> (HWND hPrevFocus) override</td></tr>
<tr class="memdesc:a95c6eb88c9f93bb135da9ee303ada3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_SETFOCUS时调用该函数  <br /></td></tr>
<tr class="separator:a95c6eb88c9f93bb135da9ee303ada3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8833ac8fe8798edd0480f737aea426" id="r_a6b8833ac8fe8798edd0480f737aea426"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a6b8833ac8fe8798edd0480f737aea426">OnKillFocus</a> (HWND hNextFocus) override</td></tr>
<tr class="memdesc:a6b8833ac8fe8798edd0480f737aea426"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_KILLFOCUS时调用该函数  <br /></td></tr>
<tr class="separator:a6b8833ac8fe8798edd0480f737aea426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9457ae52c529cd361d2b733b1324414c" id="r_a9457ae52c529cd361d2b733b1324414c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a9457ae52c529cd361d2b733b1324414c">OnChar</a> (wchar_t ch, const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;flags) override</td></tr>
<tr class="memdesc:a9457ae52c529cd361d2b733b1324414c"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_CHAR时调用该函数  <br /></td></tr>
<tr class="separator:a9457ae52c529cd361d2b733b1324414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61be9b117b4bf977bfd26938ab31ef45" id="r_a61be9b117b4bf977bfd26938ab31ef45"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a61be9b117b4bf977bfd26938ab31ef45">OnKeyDown</a> (VirtualKey key, const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;flags) override</td></tr>
<tr class="memdesc:a61be9b117b4bf977bfd26938ab31ef45"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_KEYDOWN时调用该函数  <br /></td></tr>
<tr class="separator:a61be9b117b4bf977bfd26938ab31ef45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42183341acd166a6588bee7618302273" id="r_a42183341acd166a6588bee7618302273"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a42183341acd166a6588bee7618302273">OnKeyUp</a> (VirtualKey key, const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;flags) override</td></tr>
<tr class="memdesc:a42183341acd166a6588bee7618302273"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_KEYUP时调用该函数  <br /></td></tr>
<tr class="separator:a42183341acd166a6588bee7618302273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae354a4b28227421f135b63bce8a946f0" id="r_ae354a4b28227421f135b63bce8a946f0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ae354a4b28227421f135b63bce8a946f0">OnMouseMove</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState) override</td></tr>
<tr class="memdesc:ae354a4b28227421f135b63bce8a946f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MOUSEMOVE时调用该函数  <br /></td></tr>
<tr class="separator:ae354a4b28227421f135b63bce8a946f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65b1a6485b454004801a296c788db6a" id="r_ac65b1a6485b454004801a296c788db6a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#ac65b1a6485b454004801a296c788db6a">OnMouseLeave</a> () override</td></tr>
<tr class="memdesc:ac65b1a6485b454004801a296c788db6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MOUSELEAVE时调用该函数  <br /></td></tr>
<tr class="separator:ac65b1a6485b454004801a296c788db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ba0f0dc987d1debd940249a512d0b4" id="r_a93ba0f0dc987d1debd940249a512d0b4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a93ba0f0dc987d1debd940249a512d0b4">OnMouseWheel</a> (int wheelDelta, const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState) override</td></tr>
<tr class="memdesc:a93ba0f0dc987d1debd940249a512d0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MOUSEWHEEL时调用该函数  <br /></td></tr>
<tr class="separator:a93ba0f0dc987d1debd940249a512d0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d3676b0276db01df906028229d3219" id="r_a55d3676b0276db01df906028229d3219"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a55d3676b0276db01df906028229d3219">OnMouseLeftButtonDown</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState) override</td></tr>
<tr class="memdesc:a55d3676b0276db01df906028229d3219"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_LBUTTONDOWN时调用该函数  <br /></td></tr>
<tr class="separator:a55d3676b0276db01df906028229d3219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa233cd23edacab3fdd797792ce22b86f" id="r_aa233cd23edacab3fdd797792ce22b86f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aa233cd23edacab3fdd797792ce22b86f">OnMouseLeftButtonUp</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState) override</td></tr>
<tr class="memdesc:aa233cd23edacab3fdd797792ce22b86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_LBUTTONUP时调用该函数  <br /></td></tr>
<tr class="separator:aa233cd23edacab3fdd797792ce22b86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f2f4ee091f2e7607c59f7a1a496d50" id="r_a78f2f4ee091f2e7607c59f7a1a496d50"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a78f2f4ee091f2e7607c59f7a1a496d50">OnMouseRightButtonDown</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState) override</td></tr>
<tr class="memdesc:a78f2f4ee091f2e7607c59f7a1a496d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_RBUTTONDOWN时调用该函数  <br /></td></tr>
<tr class="separator:a78f2f4ee091f2e7607c59f7a1a496d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea88ce9ca334ce6812627bf19d256e14" id="r_aea88ce9ca334ce6812627bf19d256e14"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aea88ce9ca334ce6812627bf19d256e14">OnMouseRightButtonUp</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState) override</td></tr>
<tr class="memdesc:aea88ce9ca334ce6812627bf19d256e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_RBUTTONUP时调用该函数  <br /></td></tr>
<tr class="separator:aea88ce9ca334ce6812627bf19d256e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a711a774816f7304655a18f46091d24" id="r_a7a711a774816f7304655a18f46091d24"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a7a711a774816f7304655a18f46091d24">OnMouseMiddleButtonDown</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState) override</td></tr>
<tr class="memdesc:a7a711a774816f7304655a18f46091d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MBUTTONDOWN时调用该函数  <br /></td></tr>
<tr class="separator:a7a711a774816f7304655a18f46091d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a11c2d4146eb018c4b90c8103ad8b6" id="r_a70a11c2d4146eb018c4b90c8103ad8b6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a70a11c2d4146eb018c4b90c8103ad8b6">OnMouseMiddleButtonUp</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState) override</td></tr>
<tr class="memdesc:a70a11c2d4146eb018c4b90c8103ad8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MBUTTONUP时调用该函数  <br /></td></tr>
<tr class="separator:a70a11c2d4146eb018c4b90c8103ad8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3df41032ea0fa64c548ce0ab60c746c" id="r_af3df41032ea0fa64c548ce0ab60c746c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#af3df41032ea0fa64c548ce0ab60c746c">OnContextMenu</a> (bool isKeyboardMsg, const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition) override</td></tr>
<tr class="memdesc:af3df41032ea0fa64c548ce0ab60c746c"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_CONTEXTMENU后调用目标控件的该函数  <br /></td></tr>
<tr class="separator:af3df41032ea0fa64c548ce0ab60c746c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1d15ee60f06d11aeccadfc92ed23d2" id="r_aca1d15ee60f06d11aeccadfc92ed23d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#aca1d15ee60f06d11aeccadfc92ed23d2">OnMenuCommand</a> (int id) override</td></tr>
<tr class="memdesc:aca1d15ee60f06d11aeccadfc92ed23d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">当WM_COMMAND接收到菜单命令时调用该函数  <br /></td></tr>
<tr class="separator:aca1d15ee60f06d11aeccadfc92ed23d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e16c574d3fc57a9da8ac8d9c2bf1a24" id="r_a5e16c574d3fc57a9da8ac8d9c2bf1a24"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a5e16c574d3fc57a9da8ac8d9c2bf1a24">OnColor</a> (HDC hdc, HBRUSH &amp;hRetBrush) override</td></tr>
<tr class="memdesc:a5e16c574d3fc57a9da8ac8d9c2bf1a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">父窗口接收到WM_CTLCOLORxxx时调用对应控件的该函数  <br /></td></tr>
<tr class="separator:a5e16c574d3fc57a9da8ac8d9c2bf1a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6175e146290ecff80407d4c8afa1cf05" id="r_a6175e146290ecff80407d4c8afa1cf05"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a6175e146290ecff80407d4c8afa1cf05">OnSetCursor</a> (HWND hwnd, HitTestResult hitTest, int message, bool &amp;result) override</td></tr>
<tr class="memdesc:a6175e146290ecff80407d4c8afa1cf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_SETCURSOR消息时调用该函数  <br /></td></tr>
<tr class="separator:a6175e146290ecff80407d4c8afa1cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a331869736475e10e2f861b5a242565" id="r_a6a331869736475e10e2f861b5a242565"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a6a331869736475e10e2f861b5a242565">OnDropFiles</a> (HDROP hDrop) override</td></tr>
<tr class="memdesc:a6a331869736475e10e2f861b5a242565"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_DROPFILES时调用该函数  <br /></td></tr>
<tr class="separator:a6a331869736475e10e2f861b5a242565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5535a1f79a5adb4a90dfb6a7a534fd" id="r_a7b5535a1f79a5adb4a90dfb6a7a534fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1UIElement.html#a7b5535a1f79a5adb4a90dfb6a7a534fd">OnNcHitTest</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;testPoint, HitTestResult &amp;result) override</td></tr>
<tr class="memdesc:a7b5535a1f79a5adb4a90dfb6a7a534fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_NCHITTEST后调用该函数  <br /></td></tr>
<tr class="separator:a7b5535a1f79a5adb4a90dfb6a7a534fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsw_1_1WndBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classsw_1_1WndBase')"><img src="closed.png" alt="-"/>&#160;Protected 成员函数 继承自 <a class="el" href="classsw_1_1WndBase.html">sw::WndBase</a></td></tr>
<tr class="memitem:aab509b68c9c0b612862cf41d8ef685a3 inherit pro_methods_classsw_1_1WndBase" id="r_aab509b68c9c0b612862cf41d8ef685a3"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>WndBase</b> ()</td></tr>
<tr class="memdesc:aab509b68c9c0b612862cf41d8ef685a3 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化WndBase <br /></td></tr>
<tr class="separator:aab509b68c9c0b612862cf41d8ef685a3 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39726d256f8a2ba0d3d0f8bc79c1ab96 inherit pro_methods_classsw_1_1WndBase" id="r_a39726d256f8a2ba0d3d0f8bc79c1ab96"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>WndBase</b> (const <a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp;)=delete</td></tr>
<tr class="separator:a39726d256f8a2ba0d3d0f8bc79c1ab96 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bfb3adbc06758e172fe3698151446e inherit pro_methods_classsw_1_1WndBase" id="r_a98bfb3adbc06758e172fe3698151446e"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>WndBase</b> (<a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a98bfb3adbc06758e172fe3698151446e inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ec401ebcb3c062630d8cb4521cb2dc inherit pro_methods_classsw_1_1WndBase" id="r_a69ec401ebcb3c062630d8cb4521cb2dc"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp;)=delete</td></tr>
<tr class="separator:a69ec401ebcb3c062630d8cb4521cb2dc inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd4824ac4898f164a0df2f53986aa86 inherit pro_methods_classsw_1_1WndBase" id="r_abbd4824ac4898f164a0df2f53986aa86"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsw_1_1WndBase.html">WndBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:abbd4824ac4898f164a0df2f53986aa86 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4889c45dfad820c103dd7f74f2cd0661 inherit pro_methods_classsw_1_1WndBase" id="r_a4889c45dfad820c103dd7f74f2cd0661"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitWindow</b> (LPCWSTR lpWindowName, DWORD dwStyle, DWORD dwExStyle)</td></tr>
<tr class="memdesc:a4889c45dfad820c103dd7f74f2cd0661 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化为窗口，该函数会调用CreateWindowExW <br /></td></tr>
<tr class="separator:a4889c45dfad820c103dd7f74f2cd0661 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb12507b6a8137427841d3bc4181fc6 inherit pro_methods_classsw_1_1WndBase" id="r_aecb12507b6a8137427841d3bc4181fc6"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>InitControl</b> (LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, DWORD dwExStyle, LPVOID lpParam=NULL)</td></tr>
<tr class="memdesc:aecb12507b6a8137427841d3bc4181fc6 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化为控件，该函数会调用CreateWindowExW <br /></td></tr>
<tr class="separator:aecb12507b6a8137427841d3bc4181fc6 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa551d992e7037ada1d07ad9a1504dc82 inherit pro_methods_classsw_1_1WndBase" id="r_aa551d992e7037ada1d07ad9a1504dc82"><td class="memItemLeft" align="right" valign="top">
LRESULT&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultWndProc</b> (const <a class="el" href="structsw_1_1ProcMsg.html">ProcMsg</a> &amp;msg)</td></tr>
<tr class="memdesc:aa551d992e7037ada1d07ad9a1504dc82 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">调用默认的WndProc，对于窗口则调用DefWindowProcW，控件则调用_controlOldWndProc <br /></td></tr>
<tr class="separator:aa551d992e7037ada1d07ad9a1504dc82 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22abfc80e3158636817e7db86d8ea613 inherit pro_methods_classsw_1_1WndBase" id="r_a22abfc80e3158636817e7db86d8ea613"><td class="memItemLeft" align="right" valign="top">virtual LRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a22abfc80e3158636817e7db86d8ea613">WndProc</a> (<a class="el" href="structsw_1_1ProcMsg.html">ProcMsg</a> &amp;refMsg)</td></tr>
<tr class="memdesc:a22abfc80e3158636817e7db86d8ea613 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">对WndProc的封装  <br /></td></tr>
<tr class="separator:a22abfc80e3158636817e7db86d8ea613 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670d453b91ad91d9dcd642a495df6ec2 inherit pro_methods_classsw_1_1WndBase" id="r_a670d453b91ad91d9dcd642a495df6ec2"><td class="memItemLeft" align="right" valign="top">virtual std::wstring &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a670d453b91ad91d9dcd642a495df6ec2">GetInternalText</a> ()</td></tr>
<tr class="memdesc:a670d453b91ad91d9dcd642a495df6ec2 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取内部记录窗口文本的字符串引用  <br /></td></tr>
<tr class="separator:a670d453b91ad91d9dcd642a495df6ec2 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc9851ddd21521667a73daa950b94e1 inherit pro_methods_classsw_1_1WndBase" id="r_a1fc9851ddd21521667a73daa950b94e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a1fc9851ddd21521667a73daa950b94e1">SetInternalText</a> (const std::wstring &amp;value)</td></tr>
<tr class="memdesc:a1fc9851ddd21521667a73daa950b94e1 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">修改窗口文本，该函数默认实现为调用SetWindowTextW  <br /></td></tr>
<tr class="separator:a1fc9851ddd21521667a73daa950b94e1 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd30ab5e8700832140c329739b4b671 inherit pro_methods_classsw_1_1WndBase" id="r_a7dd30ab5e8700832140c329739b4b671"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a7dd30ab5e8700832140c329739b4b671">OnCreate</a> ()</td></tr>
<tr class="memdesc:a7dd30ab5e8700832140c329739b4b671 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_CREATE时调用该函数  <br /></td></tr>
<tr class="separator:a7dd30ab5e8700832140c329739b4b671 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d960679d1889998ba548af6a3c8fc4 inherit pro_methods_classsw_1_1WndBase" id="r_a98d960679d1889998ba548af6a3c8fc4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a98d960679d1889998ba548af6a3c8fc4">OnDestroy</a> ()</td></tr>
<tr class="memdesc:a98d960679d1889998ba548af6a3c8fc4 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_DESTROY时调用该函数  <br /></td></tr>
<tr class="separator:a98d960679d1889998ba548af6a3c8fc4 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029ba4be0e492f8383f2b5fe22125acb inherit pro_methods_classsw_1_1WndBase" id="r_a029ba4be0e492f8383f2b5fe22125acb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a029ba4be0e492f8383f2b5fe22125acb">OnPaint</a> ()</td></tr>
<tr class="memdesc:a029ba4be0e492f8383f2b5fe22125acb inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_PAINT时调用该函数  <br /></td></tr>
<tr class="separator:a029ba4be0e492f8383f2b5fe22125acb inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90b0eebbaa959949cae5b736e2104aa inherit pro_methods_classsw_1_1WndBase" id="r_ad90b0eebbaa959949cae5b736e2104aa"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>OnEndPaint</b> ()</td></tr>
<tr class="memdesc:ad90b0eebbaa959949cae5b736e2104aa inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">在OnPaint函数完成之后调用该函数 <br /></td></tr>
<tr class="separator:ad90b0eebbaa959949cae5b736e2104aa inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531ea2dabbaedcce1f71075a68d88961 inherit pro_methods_classsw_1_1WndBase" id="r_a531ea2dabbaedcce1f71075a68d88961"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a531ea2dabbaedcce1f71075a68d88961">OnNcPaint</a> (HRGN hRgn)</td></tr>
<tr class="memdesc:a531ea2dabbaedcce1f71075a68d88961 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_NCPAINT时调用该函数  <br /></td></tr>
<tr class="separator:a531ea2dabbaedcce1f71075a68d88961 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e057ec7002cd6e782e7ae2e235c13b6 inherit pro_methods_classsw_1_1WndBase" id="r_a4e057ec7002cd6e782e7ae2e235c13b6"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>OnEndNcPaint</b> ()</td></tr>
<tr class="memdesc:a4e057ec7002cd6e782e7ae2e235c13b6 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">在OnNcPaint函数完成之后调用该函数 <br /></td></tr>
<tr class="separator:a4e057ec7002cd6e782e7ae2e235c13b6 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8b3628162d76997581fe6cc712b4c9 inherit pro_methods_classsw_1_1WndBase" id="r_acc8b3628162d76997581fe6cc712b4c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#acc8b3628162d76997581fe6cc712b4c9">OnMouseLeftButtonDoubleClick</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState)</td></tr>
<tr class="memdesc:acc8b3628162d76997581fe6cc712b4c9 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_LBUTTONDBLCLK时调用该函数  <br /></td></tr>
<tr class="separator:acc8b3628162d76997581fe6cc712b4c9 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b230b894e0b42f28776286b722cbccd inherit pro_methods_classsw_1_1WndBase" id="r_a6b230b894e0b42f28776286b722cbccd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a6b230b894e0b42f28776286b722cbccd">OnMouseRightButtonDoubleClick</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState)</td></tr>
<tr class="memdesc:a6b230b894e0b42f28776286b722cbccd inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_RBUTTONDBLCLK时调用该函数  <br /></td></tr>
<tr class="separator:a6b230b894e0b42f28776286b722cbccd inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f1fbc37f4cbf67052dfd4e5fe5d4ed inherit pro_methods_classsw_1_1WndBase" id="r_ae4f1fbc37f4cbf67052dfd4e5fe5d4ed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#ae4f1fbc37f4cbf67052dfd4e5fe5d4ed">OnMouseMiddleButtonDoubleClick</a> (const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;mousePosition, MouseKey keyState)</td></tr>
<tr class="memdesc:ae4f1fbc37f4cbf67052dfd4e5fe5d4ed inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MBUTTONDBLCLK时调用该函数  <br /></td></tr>
<tr class="separator:ae4f1fbc37f4cbf67052dfd4e5fe5d4ed inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b2e8bd44b2f28389d8dc93d520a06e inherit pro_methods_classsw_1_1WndBase" id="r_ad4b2e8bd44b2f28389d8dc93d520a06e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#ad4b2e8bd44b2f28389d8dc93d520a06e">OnDeadChar</a> (wchar_t ch, const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;flags)</td></tr>
<tr class="memdesc:ad4b2e8bd44b2f28389d8dc93d520a06e inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_DEADCHAR时调用该函数  <br /></td></tr>
<tr class="separator:ad4b2e8bd44b2f28389d8dc93d520a06e inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ee3de52f4250d20a743380d3d1d325 inherit pro_methods_classsw_1_1WndBase" id="r_a62ee3de52f4250d20a743380d3d1d325"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a62ee3de52f4250d20a743380d3d1d325">OnSysChar</a> (wchar_t ch, const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;flags)</td></tr>
<tr class="memdesc:a62ee3de52f4250d20a743380d3d1d325 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_SYSCHAR时调用该函数  <br /></td></tr>
<tr class="separator:a62ee3de52f4250d20a743380d3d1d325 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca103c04c1f4557c21664a6052fca40 inherit pro_methods_classsw_1_1WndBase" id="r_aeca103c04c1f4557c21664a6052fca40"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#aeca103c04c1f4557c21664a6052fca40">OnSysDeadChar</a> (wchar_t ch, const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;flags)</td></tr>
<tr class="memdesc:aeca103c04c1f4557c21664a6052fca40 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_SYSDEADCHAR时调用该函数  <br /></td></tr>
<tr class="separator:aeca103c04c1f4557c21664a6052fca40 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c78333620847e9c2dbabe332542b774 inherit pro_methods_classsw_1_1WndBase" id="r_a1c78333620847e9c2dbabe332542b774"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a1c78333620847e9c2dbabe332542b774">OnSysKeyDown</a> (VirtualKey key, const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;flags)</td></tr>
<tr class="memdesc:a1c78333620847e9c2dbabe332542b774 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_SYSKEYDOWN时调用该函数  <br /></td></tr>
<tr class="separator:a1c78333620847e9c2dbabe332542b774 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51447adf63cc72fc1f8b41e7b64a3af3 inherit pro_methods_classsw_1_1WndBase" id="r_a51447adf63cc72fc1f8b41e7b64a3af3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a51447adf63cc72fc1f8b41e7b64a3af3">OnSysKeyUp</a> (VirtualKey key, const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;flags)</td></tr>
<tr class="memdesc:a51447adf63cc72fc1f8b41e7b64a3af3 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_SYSKEYUP时调用该函数  <br /></td></tr>
<tr class="separator:a51447adf63cc72fc1f8b41e7b64a3af3 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e633e3cfea36b186c4a210925e865a inherit pro_methods_classsw_1_1WndBase" id="r_a60e633e3cfea36b186c4a210925e865a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a60e633e3cfea36b186c4a210925e865a">OnCommand</a> (int code)</td></tr>
<tr class="memdesc:a60e633e3cfea36b186c4a210925e865a inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">当父窗口接收到控件的WM_COMMAND时调用该函数  <br /></td></tr>
<tr class="separator:a60e633e3cfea36b186c4a210925e865a inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69256166096bb51cde45f101c4e9ae95 inherit pro_methods_classsw_1_1WndBase" id="r_a69256166096bb51cde45f101c4e9ae95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a69256166096bb51cde45f101c4e9ae95">OnControlCommand</a> (<a class="el" href="classsw_1_1WndBase.html">WndBase</a> *pControl, int code, int id)</td></tr>
<tr class="memdesc:a69256166096bb51cde45f101c4e9ae95 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">当WM_COMMAND接收到控件命令时调用该函数  <br /></td></tr>
<tr class="separator:a69256166096bb51cde45f101c4e9ae95 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935f2bb51b99929ac5166ad52396971a inherit pro_methods_classsw_1_1WndBase" id="r_a935f2bb51b99929ac5166ad52396971a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a935f2bb51b99929ac5166ad52396971a">OnAcceleratorCommand</a> (int id)</td></tr>
<tr class="memdesc:a935f2bb51b99929ac5166ad52396971a inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">当WM_COMMAND接收到快捷键命令时调用该函数  <br /></td></tr>
<tr class="separator:a935f2bb51b99929ac5166ad52396971a inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b368860fef40406c091880fc72f9cbb inherit pro_methods_classsw_1_1WndBase" id="r_a4b368860fef40406c091880fc72f9cbb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a4b368860fef40406c091880fc72f9cbb">HandleInitialized</a> (HWND hwnd)</td></tr>
<tr class="memdesc:a4b368860fef40406c091880fc72f9cbb inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">窗口句柄初始化完成  <br /></td></tr>
<tr class="separator:a4b368860fef40406c091880fc72f9cbb inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f645592c48b729f1dc9d6a9ed705d48 inherit pro_methods_classsw_1_1WndBase" id="r_a0f645592c48b729f1dc9d6a9ed705d48"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a0f645592c48b729f1dc9d6a9ed705d48">OnMenuSelect</a> (HMENU hMenu, int id, int flags)</td></tr>
<tr class="memdesc:a0f645592c48b729f1dc9d6a9ed705d48 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MENUSELECT后调用该函数  <br /></td></tr>
<tr class="separator:a0f645592c48b729f1dc9d6a9ed705d48 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca7ed6a3a6f07933c3412f392893970 inherit pro_methods_classsw_1_1WndBase" id="r_aeca7ed6a3a6f07933c3412f392893970"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#aeca7ed6a3a6f07933c3412f392893970">OnNotify</a> (NMHDR *pNMHDR, LRESULT &amp;result)</td></tr>
<tr class="memdesc:aeca7ed6a3a6f07933c3412f392893970 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_NOTIFY后调用该函数  <br /></td></tr>
<tr class="separator:aeca7ed6a3a6f07933c3412f392893970 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffaecd17dc15509a81024cc522b07b0 inherit pro_methods_classsw_1_1WndBase" id="r_a5ffaecd17dc15509a81024cc522b07b0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a5ffaecd17dc15509a81024cc522b07b0">OnNotified</a> (NMHDR *pNMHDR, LRESULT &amp;result)</td></tr>
<tr class="memdesc:a5ffaecd17dc15509a81024cc522b07b0 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">父窗口接收到WM_NOTIFY后且父窗口OnNotify函数返回false时调用发出通知控件的该函数  <br /></td></tr>
<tr class="separator:a5ffaecd17dc15509a81024cc522b07b0 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a4024b2096ecef4248b1c254b674e2 inherit pro_methods_classsw_1_1WndBase" id="r_a72a4024b2096ecef4248b1c254b674e2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a72a4024b2096ecef4248b1c254b674e2">OnVerticalScroll</a> (int event, int pos)</td></tr>
<tr class="memdesc:a72a4024b2096ecef4248b1c254b674e2 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_VSCROLL时调用目标控件的该函数  <br /></td></tr>
<tr class="separator:a72a4024b2096ecef4248b1c254b674e2 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6773148b0a9a1fdd3c8a0d8cd54a2fd inherit pro_methods_classsw_1_1WndBase" id="r_af6773148b0a9a1fdd3c8a0d8cd54a2fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#af6773148b0a9a1fdd3c8a0d8cd54a2fd">OnHorizontalScroll</a> (int event, int pos)</td></tr>
<tr class="memdesc:af6773148b0a9a1fdd3c8a0d8cd54a2fd inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_HSCROLL时调用目标控件的该函数  <br /></td></tr>
<tr class="separator:af6773148b0a9a1fdd3c8a0d8cd54a2fd inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755bd826227232fd30ba5fda47bfb060 inherit pro_methods_classsw_1_1WndBase" id="r_a755bd826227232fd30ba5fda47bfb060"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a755bd826227232fd30ba5fda47bfb060">OnEnabledChanged</a> (bool newValue)</td></tr>
<tr class="memdesc:a755bd826227232fd30ba5fda47bfb060 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_ENABLE时调用该函数  <br /></td></tr>
<tr class="separator:a755bd826227232fd30ba5fda47bfb060 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04cd83e79c42d21127799e573d9f299 inherit pro_methods_classsw_1_1WndBase" id="r_aa04cd83e79c42d21127799e573d9f299"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#aa04cd83e79c42d21127799e573d9f299">OnCtlColor</a> (<a class="el" href="classsw_1_1WndBase.html">WndBase</a> *pControl, HDC hdc, HBRUSH &amp;hRetBrush)</td></tr>
<tr class="memdesc:aa04cd83e79c42d21127799e573d9f299 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_CTLCOLORxxx时调用该函数  <br /></td></tr>
<tr class="separator:aa04cd83e79c42d21127799e573d9f299 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6fa4ee7f0a89966f165292c6be1e4c inherit pro_methods_classsw_1_1WndBase" id="r_afd6fa4ee7f0a89966f165292c6be1e4c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#afd6fa4ee7f0a89966f165292c6be1e4c">OnEraseBackground</a> (HDC hdc, LRESULT &amp;result)</td></tr>
<tr class="memdesc:afd6fa4ee7f0a89966f165292c6be1e4c inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_ERASEBKGND时调用该函数  <br /></td></tr>
<tr class="separator:afd6fa4ee7f0a89966f165292c6be1e4c inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9cac4e02b3a420c42968cbf061fd02 inherit pro_methods_classsw_1_1WndBase" id="r_a6e9cac4e02b3a420c42968cbf061fd02"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a6e9cac4e02b3a420c42968cbf061fd02">OnDrawItem</a> (int id, DRAWITEMSTRUCT *pDrawItem)</td></tr>
<tr class="memdesc:a6e9cac4e02b3a420c42968cbf061fd02 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_DRAWITEM时调用该函数  <br /></td></tr>
<tr class="separator:a6e9cac4e02b3a420c42968cbf061fd02 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b15a9d31f1cd1c455a36fd4f4cefe7 inherit pro_methods_classsw_1_1WndBase" id="r_a78b15a9d31f1cd1c455a36fd4f4cefe7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a78b15a9d31f1cd1c455a36fd4f4cefe7">OnDrawItemSelf</a> (DRAWITEMSTRUCT *pDrawItem)</td></tr>
<tr class="memdesc:a78b15a9d31f1cd1c455a36fd4f4cefe7 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">父窗口接收到WM_DRAWITEM后且父窗口OnDrawItem函数返回false时调用发出通知控件的该函数  <br /></td></tr>
<tr class="separator:a78b15a9d31f1cd1c455a36fd4f4cefe7 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2840d620305548116446aaf0cf99ac inherit pro_methods_classsw_1_1WndBase" id="r_a4e2840d620305548116446aaf0cf99ac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a4e2840d620305548116446aaf0cf99ac">OnMeasureItem</a> (int id, MEASUREITEMSTRUCT *pMeasure)</td></tr>
<tr class="memdesc:a4e2840d620305548116446aaf0cf99ac inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">接收到WM_MEASUREITEM时调用该函数  <br /></td></tr>
<tr class="separator:a4e2840d620305548116446aaf0cf99ac inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1241102f758c80bc7a5a85122f273ca1 inherit pro_methods_classsw_1_1WndBase" id="r_a1241102f758c80bc7a5a85122f273ca1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a1241102f758c80bc7a5a85122f273ca1">OnMeasureItemSelf</a> (MEASUREITEMSTRUCT *pMeasure)</td></tr>
<tr class="memdesc:a1241102f758c80bc7a5a85122f273ca1 inherit pro_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">父窗口接收到WM_MEASUREITEM后且父窗口OnMeasureItem函数返回false时调用发出通知控件的该函数  <br /></td></tr>
<tr class="separator:a1241102f758c80bc7a5a85122f273ca1 inherit pro_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
额外继承的成员函数</h2></td></tr>
<tr class="inherit_header pub_static_methods_classsw_1_1WndBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classsw_1_1WndBase')"><img src="closed.png" alt="-"/>&#160;静态 Public 成员函数 继承自 <a class="el" href="classsw_1_1WndBase.html">sw::WndBase</a></td></tr>
<tr class="memitem:a8d6495d0991d0329c20fe02dce07acbe inherit pub_static_methods_classsw_1_1WndBase" id="r_a8d6495d0991d0329c20fe02dce07acbe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsw_1_1WndBase.html">WndBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsw_1_1WndBase.html#a8d6495d0991d0329c20fe02dce07acbe">GetWndBase</a> (HWND hwnd) noexcept</td></tr>
<tr class="memdesc:a8d6495d0991d0329c20fe02dce07acbe inherit pub_static_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">通过窗口句柄获取WndBase  <br /></td></tr>
<tr class="separator:a8d6495d0991d0329c20fe02dce07acbe inherit pub_static_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7d3e913afb085c2024097a296db704 inherit pub_static_methods_classsw_1_1WndBase" id="r_a1e7d3e913afb085c2024097a296db704"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsPtrValid</b> (const <a class="el" href="classsw_1_1WndBase.html">WndBase</a> *ptr) noexcept</td></tr>
<tr class="memdesc:a1e7d3e913afb085c2024097a296db704 inherit pub_static_methods_classsw_1_1WndBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查指针是否指向有效的WndBase对象 <br /></td></tr>
<tr class="separator:a1e7d3e913afb085c2024097a296db704 inherit pub_static_methods_classsw_1_1WndBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>表示界面中的元素 </p>
</div><h2 class="groupheader">成员函数说明</h2>
<a id="a1576ecfeec8347256a1c43a33169e1dc" name="a1576ecfeec8347256a1c43a33169e1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1576ecfeec8347256a1c43a33169e1dc">&#9670;&#160;</a></span>AddChild() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::AddChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>添加子元素 </p>
<dl class="section return"><dt>返回</dt><dd>若函数成功则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>添加的子元素必须与当前元素在同一线程创建 </dd></dl>

</div>
</div>
<a id="a3e08b05c1a3ac1d95fd54a3ffaab81a0" name="a3e08b05c1a3ac1d95fd54a3ffaab81a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e08b05c1a3ac1d95fd54a3ffaab81a0">&#9670;&#160;</a></span>AddChild() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::AddChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>layoutTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>添加子元素并设置布局标记 </p>
<dl class="section return"><dt>返回</dt><dd>若函数成功则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>添加的子元素必须与当前元素在同一线程创建 </dd></dl>

</div>
</div>
<a id="a32893339be348aa964441954f3a31101" name="a32893339be348aa964441954f3a31101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32893339be348aa964441954f3a31101">&#9670;&#160;</a></span>AddChild() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::AddChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>添加子元素 </p>
<dl class="section return"><dt>返回</dt><dd>若函数成功则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>添加的子元素必须与当前元素在同一线程创建 </dd></dl>

</div>
</div>
<a id="ac020bc2d263e0dcffa59e0f474ea6e95" name="ac020bc2d263e0dcffa59e0f474ea6e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac020bc2d263e0dcffa59e0f474ea6e95">&#9670;&#160;</a></span>AddChild() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::AddChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>layoutTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>添加子元素并设置布局标记 </p>
<dl class="section return"><dt>返回</dt><dd>若函数成功则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>添加的子元素必须与当前元素在同一线程创建 </dd></dl>

</div>
</div>
<a id="a98f2c4d1aac620f266c6420c3310ee19" name="a98f2c4d1aac620f266c6420c3310ee19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f2c4d1aac620f266c6420c3310ee19">&#9670;&#160;</a></span>AddChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; _CanAddChildren&lt; First, Rest... &gt;::value, int &gt;::type sw::UIElement::AddChildren </td>
          <td>(</td>
          <td class="paramtype">First &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加多个子元素 </p>
<dl class="section return"><dt>返回</dt><dd>返回成功添加的子元素数量 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>当有一个子元素添加失败时后续的子元素将不会继续添加 </dd>
<dd>
添加的子元素必须与当前元素在同一线程创建 </dd></dl>

</div>
</div>
<a id="abbef9f628b10717ef28fdad71d382499" name="abbef9f628b10717ef28fdad71d382499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbef9f628b10717ef28fdad71d382499">&#9670;&#160;</a></span>AddChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; _CanAddChild&lt; T &gt;::value, int &gt;::type sw::UIElement::AddChildren </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加多个子元素 </p>
<dl class="section return"><dt>返回</dt><dd>返回成功添加的子元素数量 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>当有一个子元素添加失败时后续的子元素将不会继续添加 </dd>
<dd>
添加的子元素必须与当前元素在同一线程创建 </dd></dl>

</div>
</div>
<a id="acab825c8749c5bec592e00724f1aa83b" name="acab825c8749c5bec592e00724f1aa83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab825c8749c5bec592e00724f1aa83b">&#9670;&#160;</a></span>AddHandler() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type sw::UIElement::AddHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据事件参数类型添加路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自TypedRoutedEventArgs&lt;...&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>事件的处理函数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ab5957c173050c3e1d9ac1df9e27e7e" name="a9ab5957c173050c3e1d9ac1df9e27e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab5957c173050c3e1d9ac1df9e27e7e">&#9670;&#160;</a></span>AddHandler() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;!std::is_same&lt; TEventArgs, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &gt;::value &amp;&amp;!<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type sw::UIElement::AddHandler </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自RoutedEventArgs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c1fb1c05dee9d36a8ecc170aa9ab1be" name="a7c1fb1c05dee9d36a8ecc170aa9ab1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1fb1c05dee9d36a8ecc170aa9ab1be">&#9670;&#160;</a></span>AddHandler() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::AddHandler </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">RoutedEventHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>添加路由事件处理函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa714d3978c945ead3d364f719075cd61" name="aa714d3978c945ead3d364f719075cd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa714d3978c945ead3d364f719075cd61">&#9670;&#160;</a></span>AddHandler() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::AddHandler </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加成员函数作为路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>成员函数所在的类 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">obj</td><td>注册的成员函数所在的对象 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef2a5e3ad5ef7969547d7d3024ff9ddc" name="aef2a5e3ad5ef7969547d7d3024ff9ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2a5e3ad5ef7969547d7d3024ff9ddc">&#9670;&#160;</a></span>AddHandler() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs , typename THandleObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;!std::is_same&lt; TEventArgs, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &gt;::value &amp;&amp;!<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type sw::UIElement::AddHandler </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandleObj &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(THandleObj::*)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加成员函数作为路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自RoutedEventArgs </td></tr>
    <tr><td class="paramname">THandleObj</td><td>成员函数所在的类 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">obj</td><td>注册的成员函数所在的对象 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3a2c5888b9e0ef3b45d5f1672d692d" name="aab3a2c5888b9e0ef3b45d5f1672d692d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3a2c5888b9e0ef3b45d5f1672d692d">&#9670;&#160;</a></span>AddHandler() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs , typename THandleObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type sw::UIElement::AddHandler </td>
          <td>(</td>
          <td class="paramtype">THandleObj &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(THandleObj::*)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据事件参数类型添加成员函数作为路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自TypedRoutedEventArgs&lt;...&gt; </td></tr>
    <tr><td class="paramname">THandleObj</td><td>成员函数所在的类 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>注册的成员函数所在的对象 </td></tr>
    <tr><td class="paramname">handler</td><td>事件的处理函数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8088cf88b28c6b4a5f93cd7a66a769e" name="ac8088cf88b28c6b4a5f93cd7a66a769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8088cf88b28c6b4a5f93cd7a66a769e">&#9670;&#160;</a></span>Arrange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::Arrange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>finalPosition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安排元素位置 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">finalSize</td><td>最终元素所安排的位置 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classsw_1_1ILayout.html#a5616892d25adc2666e83211036db7d80">sw::ILayout</a>.</p>

<p>被 <a class="el" href="classsw_1_1Layer.html#a418f1f936414fd657ad11a0c0f437cdb">sw::Layer</a> , 以及 <a class="el" href="classsw_1_1PanelBase.html#ab7630a76728d4d464b0bee1bfdbdca9b">sw::PanelBase</a> 重载.</p>

</div>
</div>
<a id="a3170826168869b60a1876a3598189a65" name="a3170826168869b60a1876a3598189a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3170826168869b60a1876a3598189a65">&#9670;&#160;</a></span>ArrangeOverride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::ArrangeOverride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>finalSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>安排子元素的位置，可重写该函数以实现自定义布局 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">finalSize</td><td>可用于排列子元素的最终尺寸 </td></tr>
  </table>
  </dd>
</dl>

<p>被 <a class="el" href="classsw_1_1Layer.html#a80031c421e6f3efe2e085e6991d5535c">sw::Layer</a>, <a class="el" href="classsw_1_1PanelBase.html#a352e8f17b30de80179f4869bf5951b9f">sw::PanelBase</a> , 以及 <a class="el" href="classsw_1_1TabControl.html#afe3911adf115bf45e1ef7156f56a6b9b">sw::TabControl</a> 重载.</p>

</div>
</div>
<a id="adac916bfc631d0b2a6ff11ceaf624c9e" name="adac916bfc631d0b2a6ff11ceaf624c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac916bfc631d0b2a6ff11ceaf624c9e">&#9670;&#160;</a></span>BringIntoView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::BringIntoView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>尝试将当前元素移动到可视区域内 </p>
<dl class="section return"><dt>返回</dt><dd>若函数成功则返回true，否则返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>对于悬浮元素（Float属性为true）始终返回false </dd></dl>

</div>
</div>
<a id="a773d3d44102b709d8e7871ddd83d218e" name="a773d3d44102b709d8e7871ddd83d218e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773d3d44102b709d8e7871ddd83d218e">&#9670;&#160;</a></span>ClampDesireSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::ClampDesireSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>限定指定矩形的尺寸在最小和最大尺寸之间 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>要限定的矩形，不包含边距 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f1f2e03dc38a06d5d8241028ac7ee92" name="a5f1f2e03dc38a06d5d8241028ac7ee92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1f2e03dc38a06d5d8241028ac7ee92">&#9670;&#160;</a></span>ClampDesireSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::ClampDesireSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw_1_1Size.html">sw::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>限定指定尺寸在最小和最大尺寸之间 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>要限定的尺寸，不包含边距 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89f7d92c47cd4ec2049f7b669db30ed9" name="a89f7d92c47cd4ec2049f7b669db30ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f7d92c47cd4ec2049f7b669db30ed9">&#9670;&#160;</a></span>FontChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::FontChanged </td>
          <td>(</td>
          <td class="paramtype">HFONT&#160;</td>
          <td class="paramname"><em>hfont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>字体改变时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hfont</td><td>字体句柄 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#ac34494921eed0f67a053a9393d78bcf9">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1GroupBox.html#adab6535b853278a6f293939c0bf0cde2">sw::GroupBox</a>, <a class="el" href="classsw_1_1HwndHost.html#af3bc7099b084460532256cb60f91f85b">sw::HwndHost</a>, <a class="el" href="classsw_1_1Label.html#af5e6d5d4530ee12b52ce2ab16f180aac">sw::Label</a> , 以及 <a class="el" href="classsw_1_1SysLink.html#a6429fa1b1fc327bdbb958d695d4943cc">sw::SysLink</a> 重载.</p>

</div>
</div>
<a id="a7bda5652549fe9909e3b6b1383754b30" name="a7bda5652549fe9909e3b6b1383754b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bda5652549fe9909e3b6b1383754b30">&#9670;&#160;</a></span>GetChildBottommost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double sw::UIElement::GetChildBottommost </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取所有子元素在当前元素中最底边的位置（只考虑参与布局的子窗口且忽略悬浮的元素） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>是否更字段 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>_childBottommost字段 </dd></dl>

</div>
</div>
<a id="a3683672f3c2fc8f80e4f808aac78d262" name="a3683672f3c2fc8f80e4f808aac78d262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3683672f3c2fc8f80e4f808aac78d262">&#9670;&#160;</a></span>GetChildLayoutAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsw_1_1ILayout.html">ILayout</a> &amp; sw::UIElement::GetChildLayoutAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取对应索引处的子元素，只索引参与布局的子元素 </p>
<dl class="section note"><dt>注解</dt><dd>参与布局的子元素：即非collapsed状态的元素 </dd></dl>

<p>实现了 <a class="el" href="classsw_1_1ILayout.html#ab6a7ef612525020012594123732d24d4">sw::ILayout</a>.</p>

</div>
</div>
<a id="ab31545a385dc97ead786ecf12a2b1bb2" name="ab31545a385dc97ead786ecf12a2b1bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31545a385dc97ead786ecf12a2b1bb2">&#9670;&#160;</a></span>GetChildLayoutCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sw::UIElement::GetChildLayoutCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取参与布局的子元素数量 </p>
<dl class="section note"><dt>注解</dt><dd>参与布局的子元素：即非collapsed状态的元素 </dd></dl>

<p>实现了 <a class="el" href="classsw_1_1ILayout.html#a10281d9812c885700ffcb493f68458d9">sw::ILayout</a>.</p>

</div>
</div>
<a id="a1f0bde7d9646b68dfe7251eba908cc08" name="a1f0bde7d9646b68dfe7251eba908cc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0bde7d9646b68dfe7251eba908cc08">&#9670;&#160;</a></span>GetChildRightmost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double sw::UIElement::GetChildRightmost </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取所有子元素在当前元素中最右边的位置（只考虑参与布局的子窗口且忽略悬浮的元素） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>是否更字段 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>_childRightmost字段 </dd></dl>

</div>
</div>
<a id="a55968daf78ca80665ef03f284c72b7ac" name="a55968daf78ca80665ef03f284c72b7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55968daf78ca80665ef03f284c72b7ac">&#9670;&#160;</a></span>GetDesireSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsw_1_1Size.html">Size</a> sw::UIElement::GetDesireSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前元素所需尺寸 </p>

<p>实现了 <a class="el" href="classsw_1_1ILayout.html#ae8c5f6a25aa365b1732cda2356ea9596">sw::ILayout</a>.</p>

</div>
</div>
<a id="ac05f0f344fb485c8d450350fb72ce3d7" name="ac05f0f344fb485c8d450350fb72ce3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05f0f344fb485c8d450350fb72ce3d7">&#9670;&#160;</a></span>GetInternalArrangeOffsetX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; sw::UIElement::GetInternalArrangeOffsetX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取布局时子元素的水平偏移量 </p>
<dl class="section note"><dt>注解</dt><dd>内部使用，Layer类中通过修改该值来实现子元素的布局偏移 </dd></dl>

</div>
</div>
<a id="a2f0da875e8e26fe9a01b74cd8fc321bb" name="a2f0da875e8e26fe9a01b74cd8fc321bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0da875e8e26fe9a01b74cd8fc321bb">&#9670;&#160;</a></span>GetInternalArrangeOffsetY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; sw::UIElement::GetInternalArrangeOffsetY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取布局时子元素的垂直偏移量 </p>
<dl class="section note"><dt>注解</dt><dd>内部使用，Layer类中通过修改该值来实现子元素的布局偏移 </dd></dl>

</div>
</div>
<a id="a86a0753061a7821018b4b00a8d58346b" name="a86a0753061a7821018b4b00a8d58346b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a0753061a7821018b4b00a8d58346b">&#9670;&#160;</a></span>GetLayoutTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t sw::UIElement::GetLayoutTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取布局标记 </p>

<p>实现了 <a class="el" href="classsw_1_1ILayout.html#a9462fdb3f33c63d5953f1e8d5441341c">sw::ILayout</a>.</p>

</div>
</div>
<a id="a885fcd0ce2feb766f2e3a35ceb8fa8a5" name="a885fcd0ce2feb766f2e3a35ceb8fa8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885fcd0ce2feb766f2e3a35ceb8fa8a5">&#9670;&#160;</a></span>GetRealBackColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw_1_1Color.html">Color</a> sw::UIElement::GetRealBackColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取当前要显示的背景颜色 </p>
<dl class="section return"><dt>返回</dt><dd>当Transparent为true时获取到祖先节点中首个Transparent为false的背景颜色，否则返回当前元素的背景颜色 </dd></dl>

</div>
</div>
<a id="a00f4c0ead1a834d62c5a3e898949c3bd" name="a00f4c0ead1a834d62c5a3e898949c3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f4c0ead1a834d62c5a3e898949c3bd">&#9670;&#160;</a></span>GetRealTextColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsw_1_1Color.html">Color</a> sw::UIElement::GetRealTextColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取当前要显示的文本颜色 </p>
<dl class="section return"><dt>返回</dt><dd>当InheritTextColor为true时获取到祖先节点中首个InheritTextColor为false的文本颜色，否则返回当前元素的文本颜色 </dd></dl>

</div>
</div>
<a id="a04f8d1269f1e70d0d8131a92c5752119" name="a04f8d1269f1e70d0d8131a92c5752119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f8d1269f1e70d0d8131a92c5752119">&#9670;&#160;</a></span>GetTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t sw::UIElement::GetTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取Tag </p>

<p>实现了 <a class="el" href="classsw_1_1ITag.html#a81286c4915e9e895fd1b6698f214c18b">sw::ITag</a>.</p>

</div>
</div>
<a id="a8ff6722c909efcb10fbbc63476ab64d6" name="a8ff6722c909efcb10fbbc63476ab64d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff6722c909efcb10fbbc63476ab64d6">&#9670;&#160;</a></span>IndexOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sw::UIElement::IndexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取指定元素的索引 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>要查找的元素 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若找到指定元素则返回对应的索引，否则返回-1 </dd></dl>

</div>
</div>
<a id="a45cf2817669c10b59535acf8406a1a09" name="a45cf2817669c10b59535acf8406a1a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cf2817669c10b59535acf8406a1a09">&#9670;&#160;</a></span>IndexOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sw::UIElement::IndexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取指定元素的索引 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>要查找的元素 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若找到指定元素则返回对应的索引，否则返回-1 </dd></dl>

</div>
</div>
<a id="adf8152f31c5e109ba016316182bcec47" name="adf8152f31c5e109ba016316182bcec47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8152f31c5e109ba016316182bcec47">&#9670;&#160;</a></span>IsRoutedEventRegistered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::IsRoutedEventRegistered </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>判断路由事件是否已存在事件处理函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef217f2655c4a746606bf302edc16cf4" name="aef217f2655c4a746606bf302edc16cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef217f2655c4a746606bf302edc16cf4">&#9670;&#160;</a></span>Measure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::Measure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>availableSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>测量元素所需尺寸 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">availableSize</td><td>可用的尺寸 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classsw_1_1ILayout.html#afcdbdecd5f99cdb25b891c7dc3093fdb">sw::ILayout</a>.</p>

</div>
</div>
<a id="a8cd17e0524115089357b146545510fe8" name="a8cd17e0524115089357b146545510fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd17e0524115089357b146545510fe8">&#9670;&#160;</a></span>MeasureOverride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsw_1_1Size.html">Size</a> sw::UIElement::MeasureOverride </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>availableSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>测量元素所需尺寸，无需考虑边框和边距 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">availableSize</td><td>可用的尺寸 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回元素需要占用的尺寸，若返回Size{NAN,NAN}则使用默认实现 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>返回值除了Size{NAN,NAN}表示默认尺寸外不应包含NAN、INF、负数等非法值 </dd></dl>

<p>被 <a class="el" href="classsw_1_1BmpBox.html#a2c05d9770b8362641337b9c5cca82047">sw::BmpBox</a>, <a class="el" href="classsw_1_1ButtonBase.html#ad324d6627bbed78bedde95c2b2f8c303">sw::ButtonBase</a>, <a class="el" href="classsw_1_1Label.html#af60011c35117c1dcf0d3e90f78ed4e2c">sw::Label</a>, <a class="el" href="classsw_1_1Layer.html#a5e2f0496063c24957a3cf149a4b707bb">sw::Layer</a>, <a class="el" href="classsw_1_1PanelBase.html#a4a58f2fb05d89a9149b15dfa71c91c0c">sw::PanelBase</a>, <a class="el" href="classsw_1_1SysLink.html#a83a509b815b4ea0275918c7125020cae">sw::SysLink</a> , 以及 <a class="el" href="classsw_1_1TabControl.html#a6f7b0136a9bc3a9fbefd49d72ea9706e">sw::TabControl</a> 重载.</p>

</div>
</div>
<a id="ae3e134d807af7614e1cc812abb860762" name="ae3e134d807af7614e1cc812abb860762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e134d807af7614e1cc812abb860762">&#9670;&#160;</a></span>OnAddedChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::OnAddedChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加子元素后调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>添加的子元素 </td></tr>
  </table>
  </dd>
</dl>

<p>被 <a class="el" href="classsw_1_1TabControl.html#a6a4c0d7c81d279669765feaef0f55ecd">sw::TabControl</a> 重载.</p>

</div>
</div>
<a id="a9457ae52c529cd361d2b733b1324414c" name="a9457ae52c529cd361d2b733b1324414c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9457ae52c529cd361d2b733b1324414c">&#9670;&#160;</a></span>OnChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnChar </td>
          <td>(</td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_CHAR时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>按键的字符代码 </td></tr>
    <tr><td class="paramname">flags</td><td>附加信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a60fba14ac0361232a5e640f495a7fba0">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1TextBoxBase.html#a71d8b79ffbb9de3ab8cdbccd359cd174">sw::TextBoxBase</a> 重载.</p>

</div>
</div>
<a id="a1c1f0b6a491e639c76e46a29bff00d65" name="a1c1f0b6a491e639c76e46a29bff00d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1f0b6a491e639c76e46a29bff00d65">&#9670;&#160;</a></span>OnClose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnClose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_CLOSE时调用该函数 </p>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a0e30c4d0b87c473115e7521c5c95703a">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1Window.html#a50969fbd9f30ad27e72f11cb28ee4697">sw::Window</a> 重载.</p>

</div>
</div>
<a id="a5e16c574d3fc57a9da8ac8d9c2bf1a24" name="a5e16c574d3fc57a9da8ac8d9c2bf1a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e16c574d3fc57a9da8ac8d9c2bf1a24">&#9670;&#160;</a></span>OnColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnColor </td>
          <td>(</td>
          <td class="paramtype">HDC&#160;</td>
          <td class="paramname"><em>hdc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HBRUSH &amp;&#160;</td>
          <td class="paramname"><em>hRetBrush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>父窗口接收到WM_CTLCOLORxxx时调用对应控件的该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hdc</td><td>控件的显示上下文句柄 </td></tr>
    <tr><td class="paramname">hRetBrush</td><td>要返回的画笔 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若返回true则将hRetBrush作为消息的返回值，否则使用DefaultWndProc的返回值 </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#aa605b4a21b4cd8c43c226349665a5f28">sw::WndBase</a> .</p>

</div>
</div>
<a id="af3df41032ea0fa64c548ce0ab60c746c" name="af3df41032ea0fa64c548ce0ab60c746c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3df41032ea0fa64c548ce0ab60c746c">&#9670;&#160;</a></span>OnContextMenu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnContextMenu </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isKeyboardMsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_CONTEXTMENU后调用目标控件的该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">isKeyboardMsg</td><td>消息是否由按下快捷键（Shift+F10、VK_APPS）产生 </td></tr>
    <tr><td class="paramname">mousePosition</td><td>鼠标在屏幕中的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#acfefd4f96ba2f86a0fe50b018ddff4e9">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1ListBox.html#ae8550ccdf67c411e0a3afd12ec85fccb">sw::ListBox</a> , 以及 <a class="el" href="classsw_1_1SplitButton.html#a42bf222affbe15840a33557e6fc6b63d">sw::SplitButton</a> 重载.</p>

</div>
</div>
<a id="a6a331869736475e10e2f861b5a242565" name="a6a331869736475e10e2f861b5a242565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a331869736475e10e2f861b5a242565">&#9670;&#160;</a></span>OnDropFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnDropFiles </td>
          <td>(</td>
          <td class="paramtype">HDROP&#160;</td>
          <td class="paramname"><em>hDrop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_DROPFILES时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDrop</td><td>描述拖入文件的句柄 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a9e95c73d7ac95cf80a1f49a970703b0b">sw::WndBase</a> .</p>

</div>
</div>
<a id="a61be9b117b4bf977bfd26938ab31ef45" name="a61be9b117b4bf977bfd26938ab31ef45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61be9b117b4bf977bfd26938ab31ef45">&#9670;&#160;</a></span>OnKeyDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnKeyDown </td>
          <td>(</td>
          <td class="paramtype">VirtualKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_KEYDOWN时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>虚拟按键 </td></tr>
    <tr><td class="paramname">flags</td><td>附加信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#af55f448ee982e542b5e42ab91c3182c0">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1Button.html#ac454e27e20b2d8bff66e89189cf47ec1">sw::Button</a>, <a class="el" href="classsw_1_1CommandLink.html#a590696c3e9ea6ffa591afc1bdf47c7c5">sw::CommandLink</a>, <a class="el" href="classsw_1_1DockSplitter.html#a17eedabf44e394f3a07a45c02544272a">sw::DockSplitter</a> , 以及 <a class="el" href="classsw_1_1TextBoxBase.html#af5e2405bb4f132bbfd496b024e3607a2">sw::TextBoxBase</a> 重载.</p>

</div>
</div>
<a id="a42183341acd166a6588bee7618302273" name="a42183341acd166a6588bee7618302273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42183341acd166a6588bee7618302273">&#9670;&#160;</a></span>OnKeyUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnKeyUp </td>
          <td>(</td>
          <td class="paramtype">VirtualKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsw_1_1KeyFlags.html">KeyFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_KEYUP时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>虚拟按键 </td></tr>
    <tr><td class="paramname">flags</td><td>附加信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a5baecf7eb7545e8a6abbc89f3b2cb875">sw::WndBase</a> .</p>

</div>
</div>
<a id="a6b8833ac8fe8798edd0480f737aea426" name="a6b8833ac8fe8798edd0480f737aea426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8833ac8fe8798edd0480f737aea426">&#9670;&#160;</a></span>OnKillFocus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnKillFocus </td>
          <td>(</td>
          <td class="paramtype">HWND&#160;</td>
          <td class="paramname"><em>hNextFocus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_KILLFOCUS时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hNextFocus</td><td>接收到焦点的hwnd，可能为NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a6de15bd6a264721f6bfadd40d9fce3b0">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1Button.html#a367d1dfa43e065dbe2a0272d4cfef458">sw::Button</a>, <a class="el" href="classsw_1_1CommandLink.html#afb62004ffbe64b4f930aa146fb577b79">sw::CommandLink</a>, <a class="el" href="classsw_1_1DockSplitter.html#aab1db4ae915f5abe6856a2a571f2afdc">sw::DockSplitter</a> , 以及 <a class="el" href="classsw_1_1SpinBox.html#ae07d95b786278ee289eb9fdf9ba3aa99">sw::SpinBox</a> 重载.</p>

</div>
</div>
<a id="aca1d15ee60f06d11aeccadfc92ed23d2" name="aca1d15ee60f06d11aeccadfc92ed23d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1d15ee60f06d11aeccadfc92ed23d2">&#9670;&#160;</a></span>OnMenuCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::OnMenuCommand </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当WM_COMMAND接收到菜单命令时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>菜单id </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#afffc1d57f289f965bc50d8150c4586e1">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1Window.html#a8ff6176f2fb886593f448b430c21fc90">sw::Window</a> 重载.</p>

</div>
</div>
<a id="ae8a626b2927a2b0ecabfb2dd6d8b47b3" name="ae8a626b2927a2b0ecabfb2dd6d8b47b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a626b2927a2b0ecabfb2dd6d8b47b3">&#9670;&#160;</a></span>OnMinMaxSizeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::OnMinMaxSizeChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当MinWidth、MinHeight、MaxWidth或MaxHeight属性更改时调用此函数 </p>

<p>被 <a class="el" href="classsw_1_1Window.html#a97bf0daa8e8c902a26628926f2900470">sw::Window</a> 重载.</p>

</div>
</div>
<a id="ac65b1a6485b454004801a296c788db6a" name="ac65b1a6485b454004801a296c788db6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65b1a6485b454004801a296c788db6a">&#9670;&#160;</a></span>OnMouseLeave()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseLeave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_MOUSELEAVE时调用该函数 </p>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#aaf334072263bea6dddf93a7601979023">sw::WndBase</a> .</p>

</div>
</div>
<a id="a55d3676b0276db01df906028229d3219" name="a55d3676b0276db01df906028229d3219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d3676b0276db01df906028229d3219">&#9670;&#160;</a></span>OnMouseLeftButtonDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseLeftButtonDown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MouseKey&#160;</td>
          <td class="paramname"><em>keyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_LBUTTONDOWN时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mousePosition</td><td>鼠标在用户区中的位置 </td></tr>
    <tr><td class="paramname">keyState</td><td>指示某些按键是否按下 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a43dde7384b3e346f8ce3684fee9d743d">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1DockSplitter.html#a76baeb1e26c0227943dcfd076e52b6f7">sw::DockSplitter</a> 重载.</p>

</div>
</div>
<a id="aa233cd23edacab3fdd797792ce22b86f" name="aa233cd23edacab3fdd797792ce22b86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa233cd23edacab3fdd797792ce22b86f">&#9670;&#160;</a></span>OnMouseLeftButtonUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseLeftButtonUp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MouseKey&#160;</td>
          <td class="paramname"><em>keyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_LBUTTONUP时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mousePosition</td><td>鼠标在用户区中的位置 </td></tr>
    <tr><td class="paramname">keyState</td><td>指示某些按键是否按下 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a477909b49b27614deb05bc768627c164">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1DockSplitter.html#afa3ea4fb04c142ac5d69bb6a1b3576de">sw::DockSplitter</a> 重载.</p>

</div>
</div>
<a id="a7a711a774816f7304655a18f46091d24" name="a7a711a774816f7304655a18f46091d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a711a774816f7304655a18f46091d24">&#9670;&#160;</a></span>OnMouseMiddleButtonDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseMiddleButtonDown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MouseKey&#160;</td>
          <td class="paramname"><em>keyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_MBUTTONDOWN时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mousePosition</td><td>鼠标在用户区中的位置 </td></tr>
    <tr><td class="paramname">keyState</td><td>指示某些按键是否按下 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a56bd69dcd220f4cc46dff4808d5f8ed5">sw::WndBase</a> .</p>

</div>
</div>
<a id="a70a11c2d4146eb018c4b90c8103ad8b6" name="a70a11c2d4146eb018c4b90c8103ad8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a11c2d4146eb018c4b90c8103ad8b6">&#9670;&#160;</a></span>OnMouseMiddleButtonUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseMiddleButtonUp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MouseKey&#160;</td>
          <td class="paramname"><em>keyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_MBUTTONUP时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mousePosition</td><td>鼠标在用户区中的位置 </td></tr>
    <tr><td class="paramname">keyState</td><td>指示某些按键是否按下 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#aee570e7614555dd220cd8e05b99b6bae">sw::WndBase</a> .</p>

</div>
</div>
<a id="ae354a4b28227421f135b63bce8a946f0" name="ae354a4b28227421f135b63bce8a946f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae354a4b28227421f135b63bce8a946f0">&#9670;&#160;</a></span>OnMouseMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseMove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MouseKey&#160;</td>
          <td class="paramname"><em>keyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_MOUSEMOVE时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mousePosition</td><td>鼠标在用户区中的位置 </td></tr>
    <tr><td class="paramname">keyState</td><td>指示某些按键是否按下 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a82e143fbdcb891334b692b169a733c7e">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1DockSplitter.html#ad361611e408cb50a840df7502bb13093">sw::DockSplitter</a> 重载.</p>

</div>
</div>
<a id="a78f2f4ee091f2e7607c59f7a1a496d50" name="a78f2f4ee091f2e7607c59f7a1a496d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f2f4ee091f2e7607c59f7a1a496d50">&#9670;&#160;</a></span>OnMouseRightButtonDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseRightButtonDown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MouseKey&#160;</td>
          <td class="paramname"><em>keyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_RBUTTONDOWN时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mousePosition</td><td>鼠标在用户区中的位置 </td></tr>
    <tr><td class="paramname">keyState</td><td>指示某些按键是否按下 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a1a7bb416f292962791d28e016d214bdb">sw::WndBase</a> .</p>

</div>
</div>
<a id="aea88ce9ca334ce6812627bf19d256e14" name="aea88ce9ca334ce6812627bf19d256e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea88ce9ca334ce6812627bf19d256e14">&#9670;&#160;</a></span>OnMouseRightButtonUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseRightButtonUp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MouseKey&#160;</td>
          <td class="paramname"><em>keyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_RBUTTONUP时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mousePosition</td><td>鼠标在用户区中的位置 </td></tr>
    <tr><td class="paramname">keyState</td><td>指示某些按键是否按下 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a3f4dfeacd473153df4ffc127811964f3">sw::WndBase</a> .</p>

</div>
</div>
<a id="a93ba0f0dc987d1debd940249a512d0b4" name="a93ba0f0dc987d1debd940249a512d0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ba0f0dc987d1debd940249a512d0b4">&#9670;&#160;</a></span>OnMouseWheel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMouseWheel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wheelDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>mousePosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MouseKey&#160;</td>
          <td class="paramname"><em>keyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_MOUSEWHEEL时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">wheelDelta</td><td>滚轮滚动的距离，为120的倍数 </td></tr>
    <tr><td class="paramname">mousePosition</td><td>鼠标在用户区中的位置 </td></tr>
    <tr><td class="paramname">keyState</td><td>指示某些按键是否按下 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a0ce21fe54fa57b979e383a12ce3c53fd">sw::WndBase</a> .</p>

</div>
</div>
<a id="a1708a7be0d9ffdcc18ee89413a7ca55a" name="a1708a7be0d9ffdcc18ee89413a7ca55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1708a7be0d9ffdcc18ee89413a7ca55a">&#9670;&#160;</a></span>OnMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnMove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>newClientPosition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_MOVE时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">newClientPosition</td><td>移动后用户区左上角的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a98a8d36eaebab541f09d85511022e379">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1SpinBox.html#a128141d21929f17c1a605314ce28838d">sw::SpinBox</a> 重载.</p>

</div>
</div>
<a id="a7b5535a1f79a5adb4a90dfb6a7a534fd" name="a7b5535a1f79a5adb4a90dfb6a7a534fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5535a1f79a5adb4a90dfb6a7a534fd">&#9670;&#160;</a></span>OnNcHitTest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::OnNcHitTest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>testPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HitTestResult &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_NCHITTEST后调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">testPoint</td><td>要测试的点在屏幕中的位置 </td></tr>
    <tr><td class="paramname">result</td><td>测试的结果，默认为调用DefaultWndProc的结果 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a1445af2018a8e840a25a7487da22c51b">sw::WndBase</a> .</p>

</div>
</div>
<a id="aadedba1a9bca85555b70bc247b8ef835" name="aadedba1a9bca85555b70bc247b8ef835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadedba1a9bca85555b70bc247b8ef835">&#9670;&#160;</a></span>OnRemovedChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::OnRemovedChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除子元素后调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>移除的子元素 </td></tr>
  </table>
  </dd>
</dl>

<p>被 <a class="el" href="classsw_1_1TabControl.html#a1642e450b1cf606338eb85bd9f93c82c">sw::TabControl</a> 重载.</p>

</div>
</div>
<a id="a98721f9d3c1069b5afc6188e22145f5d" name="a98721f9d3c1069b5afc6188e22145f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98721f9d3c1069b5afc6188e22145f5d">&#9670;&#160;</a></span>OnRoutedEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnRoutedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>eventArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">RoutedEventHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>路由事件经过当前元素时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventArgs</td><td>事件参数 </td></tr>
    <tr><td class="paramname">handler</td><td>事件处理函数，值为空时表示当前元素没有注册该事件处理函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该事件则返回true，否则返回false以继调用处理函数 </dd></dl>

<p>被 <a class="el" href="classsw_1_1Layer.html#a42acd68b3ac25678fb89feedb4508f9c">sw::Layer</a> , 以及 <a class="el" href="classsw_1_1PanelBase.html#ae37c8868960f5a50de13a1d13c634bd9">sw::PanelBase</a> 重载.</p>

</div>
</div>
<a id="a6175e146290ecff80407d4c8afa1cf05" name="a6175e146290ecff80407d4c8afa1cf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6175e146290ecff80407d4c8afa1cf05">&#9670;&#160;</a></span>OnSetCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnSetCursor </td>
          <td>(</td>
          <td class="paramtype">HWND&#160;</td>
          <td class="paramname"><em>hwnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HitTestResult&#160;</td>
          <td class="paramname"><em>hitTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_SETCURSOR消息时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwnd</td><td>鼠标所在窗口的句柄 </td></tr>
    <tr><td class="paramname">hitTest</td><td>hit-test的结果，详见WM_NCHITTEST消息的返回值 </td></tr>
    <tr><td class="paramname">message</td><td>触发该事件的鼠标消息，如WM_MOUSEMOVE </td></tr>
    <tr><td class="paramname">result</td><td>消息的返回值，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若返回true则将result作为消息的返回值，否则使用DefaultWndProc的返回值 </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#ab37c3f3ea7654eb6a0b15405196c4549">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1DockSplitter.html#abdf4fb3e8320ea017e38930eee045688">sw::DockSplitter</a> 重载.</p>

</div>
</div>
<a id="a95c6eb88c9f93bb135da9ee303ada3be" name="a95c6eb88c9f93bb135da9ee303ada3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c6eb88c9f93bb135da9ee303ada3be">&#9670;&#160;</a></span>OnSetFocus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnSetFocus </td>
          <td>(</td>
          <td class="paramtype">HWND&#160;</td>
          <td class="paramname"><em>hPrevFocus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_SETFOCUS时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hPrevFocus</td><td>丢失焦点的hwnd，可能为NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a4b15e8f2bcac32da4d5e540445ae201a">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1Button.html#a7ef48914988a2c38835ff09dee5c5040">sw::Button</a>, <a class="el" href="classsw_1_1CommandLink.html#a31cfe3cc1b3e1b69caaf1d252ee423c4">sw::CommandLink</a> , 以及 <a class="el" href="classsw_1_1IPAddressControl.html#a10458a0733ba951af3076861009fe45f">sw::IPAddressControl</a> 重载.</p>

</div>
</div>
<a id="a6fb5d81280aa50310db09d57145712cd" name="a6fb5d81280aa50310db09d57145712cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb5d81280aa50310db09d57145712cd">&#9670;&#160;</a></span>OnSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::OnSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>newClientSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>接收到WM_SIZE时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">newClientSize</td><td>改变后的用户区尺寸 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该消息则返回true，否则返回false以调用DefaultWndProc </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#ae79de6591e42402a1840c8fad551a8fe">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1BmpBox.html#ae756f70d8eaca4c0cd35a19cb83926f8">sw::BmpBox</a>, <a class="el" href="classsw_1_1HwndHost.html#a4c80837686f066a88b11a023215faff0">sw::HwndHost</a>, <a class="el" href="classsw_1_1IPAddressControl.html#a86e32d2f34c187ca14bd6f81e8ec989b">sw::IPAddressControl</a>, <a class="el" href="classsw_1_1Label.html#a206150fe8586a0d5e0883d4c85e81d79">sw::Label</a>, <a class="el" href="classsw_1_1SpinBox.html#a9915a229f331976be17720c9b3f8260e">sw::SpinBox</a> , 以及 <a class="el" href="classsw_1_1Splitter.html#aa637112d14f1dd06f4221ea14c1eac95">sw::Splitter</a> 重载.</p>

</div>
</div>
<a id="a71d4134a17b2953346dc9895cd01ce85" name="a71d4134a17b2953346dc9895cd01ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d4134a17b2953346dc9895cd01ce85">&#9670;&#160;</a></span>OnTabMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::OnTabMove </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>通过tab键将焦点从当前元素移出时调用该函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">forward</td><td>指示焦点移动的方向，true表示向后移动，false表示向前移动 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e1fbc142c7cfe4a4a60959daf0753bc" name="a7e1fbc142c7cfe4a4a60959daf0753bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1fbc142c7cfe4a4a60959daf0753bc">&#9670;&#160;</a></span>OnTextChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::OnTextChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Text属性更改时调用此函数 </p>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#adb808283f6ccd5a32834ad25fa2f407b">sw::WndBase</a> .</p>

<p>被 <a class="el" href="classsw_1_1GroupBox.html#a4d0d1b3d91f4b6ba8657a7a36f66eb9c">sw::GroupBox</a>, <a class="el" href="classsw_1_1Label.html#af90d6f76f8d674ae945193f3f4f630e9">sw::Label</a> , 以及 <a class="el" href="classsw_1_1SysLink.html#a1e9809bbbdea81a36919060d271b5051">sw::SysLink</a> 重载.</p>

</div>
</div>
<a id="a87b86762809c8e4a0ace610a977caa78" name="a87b86762809c8e4a0ace610a977caa78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b86762809c8e4a0ace610a977caa78">&#9670;&#160;</a></span>ParentChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::ParentChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1WndBase.html">WndBase</a> *&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>父窗口改变时调用此函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>新的父窗口 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a4d09cfbc382789150798ff6ad3d9f988">sw::WndBase</a> .</p>

</div>
</div>
<a id="a6121cdf84c8073bae9b3cde98a6a59ea" name="a6121cdf84c8073bae9b3cde98a6a59ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6121cdf84c8073bae9b3cde98a6a59ea">&#9670;&#160;</a></span>QueryAllChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::QueryAllChildren </td>
          <td>(</td>
          <td class="paramtype">const Func&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> *, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>queryFunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>查询所有子元素，直到queryFunc返回false或所有子元素均被查询 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryFunc</td><td>查询函数，参数为子元素指针，返回值为bool，返回false时停止查询 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若queryFunc在某次调用中返回false则返回false，否则返回true </dd></dl>

</div>
</div>
<a id="a135d4fc74c3bf7a434271620944b9f9b" name="a135d4fc74c3bf7a434271620944b9f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135d4fc74c3bf7a434271620944b9f9b">&#9670;&#160;</a></span>RaiseRoutedEvent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::RaiseRoutedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>eventArgs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>触发路由事件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventArgs</td><td>要触发事件的事件参数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0635558e1928f1144566a30b884303aa" name="a0635558e1928f1144566a30b884303aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0635558e1928f1144566a30b884303aa">&#9670;&#160;</a></span>RaiseRoutedEvent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::RaiseRoutedEvent </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>触发路由事件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>事件类型 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b9301a84ed462c3c1968b0bc95ed4c9" name="a2b9301a84ed462c3c1968b0bc95ed4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9301a84ed462c3c1968b0bc95ed4c9">&#9670;&#160;</a></span>RegisterRoutedEvent() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type sw::UIElement::RegisterRoutedEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据事件参数类型注册路由事件，当事件已注册时会覆盖已注册的函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自TypedRoutedEventArgs&lt;...&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>事件的处理函数，当值为nullptr时可取消注册 </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">弃用:</a></b></dt><dd>建议使用AddHandler函数代替以避免覆盖已注册的事件处理函数 </dd></dl>

</div>
</div>
<a id="a2cfb72d4ea1966ec455e7805f0931205" name="a2cfb72d4ea1966ec455e7805f0931205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfb72d4ea1966ec455e7805f0931205">&#9670;&#160;</a></span>RegisterRoutedEvent() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::RegisterRoutedEvent </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">RoutedEventHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>注册路由事件处理函数，当事件已注册时会覆盖已注册的函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数，当值为nullptr时可取消注册 </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">弃用:</a></b></dt><dd>建议使用AddHandler函数代替以避免覆盖已注册的事件处理函数 </dd></dl>

</div>
</div>
<a id="a09946400c66a4bfd34cfb8918652a34a" name="a09946400c66a4bfd34cfb8918652a34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09946400c66a4bfd34cfb8918652a34a">&#9670;&#160;</a></span>RegisterRoutedEvent() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::RegisterRoutedEvent </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>注册成员函数作为路由事件处理函数，当事件已注册时会覆盖已注册的函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>成员函数所在的类 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">obj</td><td>注册的成员函数所在的对象 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数，当值为nullptr时可取消注册 </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">弃用:</a></b></dt><dd>建议使用AddHandler函数代替以避免覆盖已注册的事件处理函数 </dd></dl>

</div>
</div>
<a id="a2da85633be22eec70448cf110914e7de" name="a2da85633be22eec70448cf110914e7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da85633be22eec70448cf110914e7de">&#9670;&#160;</a></span>RegisterRoutedEvent() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs , typename THandleObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value &gt;::type sw::UIElement::RegisterRoutedEvent </td>
          <td>(</td>
          <td class="paramtype">THandleObj &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(THandleObj::*)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据事件参数类型注册成员函数作为路由事件，当事件已注册时会覆盖已注册的函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自TypedRoutedEventArgs&lt;...&gt; </td></tr>
    <tr><td class="paramname">THandleObj</td><td>成员函数所在的类 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>注册的成员函数所在的对象 </td></tr>
    <tr><td class="paramname">handler</td><td>事件的处理函数，当值为nullptr时可取消注册 </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">弃用:</a></b></dt><dd>建议使用AddHandler函数代替以避免覆盖已注册的事件处理函数 </dd></dl>

</div>
</div>
<a id="a9e825715639370ad2dd1f1276e6cb97f" name="a9e825715639370ad2dd1f1276e6cb97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e825715639370ad2dd1f1276e6cb97f">&#9670;&#160;</a></span>RemoveChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::RemoveChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>移除子元素 </p>
<dl class="section return"><dt>返回</dt><dd>移除是否成功 </dd></dl>

</div>
</div>
<a id="a925353891b62cb6989410d788a8a4e90" name="a925353891b62cb6989410d788a8a4e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925353891b62cb6989410d788a8a4e90">&#9670;&#160;</a></span>RemoveChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::RemoveChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1UIElement.html">UIElement</a> *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>移除子元素 </p>
<dl class="section return"><dt>返回</dt><dd>移除是否成功 </dd></dl>

</div>
</div>
<a id="a622a68f74b9122c0de9c57e547b0a62b" name="a622a68f74b9122c0de9c57e547b0a62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622a68f74b9122c0de9c57e547b0a62b">&#9670;&#160;</a></span>RemoveChildAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::RemoveChildAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>移除指定索引处的子元素 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>要移除的索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>移除是否成功 </dd></dl>

</div>
</div>
<a id="afff721cb3127445c11f63e9b92ca3b56" name="afff721cb3127445c11f63e9b92ca3b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff721cb3127445c11f63e9b92ca3b56">&#9670;&#160;</a></span>RemoveHandler() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value, bool &gt;::type sw::UIElement::RemoveHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除已添加的路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自TypedRoutedEventArgs&lt;...&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>事件的处理函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否成功移除 </dd></dl>

</div>
</div>
<a id="affa7e59d71b6371dba12676c4d273025" name="affa7e59d71b6371dba12676c4d273025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa7e59d71b6371dba12676c4d273025">&#9670;&#160;</a></span>RemoveHandler() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;!std::is_same&lt; TEventArgs, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &gt;::value &amp;&amp;!<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value, bool &gt;::type sw::UIElement::RemoveHandler </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">Action</a>&lt; <a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除已添加的路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自RoutedEventArgs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否成功移除 </dd></dl>

</div>
</div>
<a id="a923d78e615a08c39522cbc3655080cd1" name="a923d78e615a08c39522cbc3655080cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923d78e615a08c39522cbc3655080cd1">&#9670;&#160;</a></span>RemoveHandler() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::RemoveHandler </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsw_1_1Delegate.html">RoutedEventHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>移除已添加的路由事件处理函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否成功移除 </dd></dl>

</div>
</div>
<a id="a6bea1478f7f4ddbccf55b7a046b87d7e" name="a6bea1478f7f4ddbccf55b7a046b87d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bea1478f7f4ddbccf55b7a046b87d7e">&#9670;&#160;</a></span>RemoveHandler() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::RemoveHandler </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &amp;)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除已添加的类型为成员函数的路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>成员函数所在的类 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">obj</td><td>注册的成员函数所在的对象 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否成功移除 </dd></dl>

</div>
</div>
<a id="a21adb2c61d1f22cd67ea99c025e1be4b" name="a21adb2c61d1f22cd67ea99c025e1be4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21adb2c61d1f22cd67ea99c025e1be4b">&#9670;&#160;</a></span>RemoveHandler() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs , typename THandleObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;!std::is_same&lt; TEventArgs, <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a> &gt;::value &amp;&amp;!<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value, bool &gt;::type sw::UIElement::RemoveHandler </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandleObj &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(THandleObj::*)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除已添加的类型为成员函数的路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自RoutedEventArgs </td></tr>
    <tr><td class="paramname">THandleObj</td><td>成员函数所在的类 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
    <tr><td class="paramname">obj</td><td>注册的成员函数所在的对象 </td></tr>
    <tr><td class="paramname">handler</td><td>处理函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否成功移除 </dd></dl>

</div>
</div>
<a id="a6f207de6bae76e8a95c6cc28adef5063" name="a6f207de6bae76e8a95c6cc28adef5063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f207de6bae76e8a95c6cc28adef5063">&#9670;&#160;</a></span>RemoveHandler() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEventArgs , typename THandleObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structsw_1_1RoutedEventArgs.html">RoutedEventArgs</a>, TEventArgs &gt;::value &amp;&amp;<a class="el" href="structsw_1_1__IsTypedRoutedEventArgs.html">sw::_IsTypedRoutedEventArgs</a>&lt; TEventArgs &gt;::value, bool &gt;::type sw::UIElement::RemoveHandler </td>
          <td>(</td>
          <td class="paramtype">THandleObj &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(THandleObj::*)(<a class="el" href="classsw_1_1UIElement.html">UIElement</a> &amp;, TEventArgs &amp;)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>移除已添加的类型为成员函数的路由事件处理函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEventArgs</td><td>路由事件的参数类型，必须继承自TypedRoutedEventArgs&lt;...&gt; </td></tr>
    <tr><td class="paramname">THandleObj</td><td>成员函数所在的类 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>注册的成员函数所在的对象 </td></tr>
    <tr><td class="paramname">handler</td><td>事件的处理函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>是否成功移除 </dd></dl>

</div>
</div>
<a id="ac5ca4318678de46f4f265f2f98701c1e" name="ac5ca4318678de46f4f265f2f98701c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ca4318678de46f4f265f2f98701c1e">&#9670;&#160;</a></span>RequestBringIntoView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::RequestBringIntoView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Rect.html">sw::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>screenRect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试将指定的矩形区域移动到可视区域内 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenRect</td><td>要移动到可视区域的矩形在屏幕中的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若已处理该请求则返回true，否则返回false以继续向上冒泡 </dd></dl>

<p>被 <a class="el" href="classsw_1_1Layer.html#a4d935eb61b4ec814264e24f2bb820789">sw::Layer</a> , 以及 <a class="el" href="classsw_1_1PanelBase.html#a0267c958f323ec15f3cd01a79cc41727">sw::PanelBase</a> 重载.</p>

</div>
</div>
<a id="aa6442acf30572cc5708fad45d227d130" name="aa6442acf30572cc5708fad45d227d130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6442acf30572cc5708fad45d227d130">&#9670;&#160;</a></span>Resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::Resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>调整当前元素的尺寸 </p>
<dl class="section note"><dt>注解</dt><dd>通过该函数可以调整横向或纵向对齐方式为拉伸时的DesireSize </dd></dl>

</div>
</div>
<a id="a7b2f0c77c7ec5d6d68bc3c772a72201a" name="a7b2f0c77c7ec5d6d68bc3c772a72201a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2f0c77c7ec5d6d68bc3c772a72201a">&#9670;&#160;</a></span>SetAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::SetAlignment </td>
          <td>(</td>
          <td class="paramtype">sw::HorizontalAlignment&#160;</td>
          <td class="paramname"><em>horz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sw::VerticalAlignment&#160;</td>
          <td class="paramname"><em>vert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>设置对齐方式 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">horz</td><td>水平对齐方式 </td></tr>
    <tr><td class="paramname">vert</td><td>垂直对齐方式 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60b45de9f894f4fb152491413f1fa73" name="af60b45de9f894f4fb152491413f1fa73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60b45de9f894f4fb152491413f1fa73">&#9670;&#160;</a></span>SetBackColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::SetBackColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>redraw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置背景颜色 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>要设置的颜色 </td></tr>
    <tr><td class="paramname">redraw</td><td>是否重绘 </td></tr>
  </table>
  </dd>
</dl>

<p>被 <a class="el" href="classsw_1_1GroupBox.html#a6e799dffb07ae89efdb53428d2602778">sw::GroupBox</a>, <a class="el" href="classsw_1_1ListView.html#a56b546d6ddeadd258522b2441ec9bcc4">sw::ListView</a>, <a class="el" href="classsw_1_1MonthCalendar.html#a2422390122597047226c500dc896f7cb">sw::MonthCalendar</a>, <a class="el" href="classsw_1_1StatusBar.html#a5edad75db8b47a0d137077e03c2cc9d6">sw::StatusBar</a> , 以及 <a class="el" href="classsw_1_1TreeView.html#a07fb6a7307dd4a059c18e526c4393f61">sw::TreeView</a> 重载.</p>

</div>
</div>
<a id="a0ce7edc8a920e950a9a75cf1a84ea627" name="a0ce7edc8a920e950a9a75cf1a84ea627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce7edc8a920e950a9a75cf1a84ea627">&#9670;&#160;</a></span>SetCursor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::SetCursor </td>
          <td>(</td>
          <td class="paramtype">HCURSOR&#160;</td>
          <td class="paramname"><em>hCursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>设置鼠标样式 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hCursor</td><td>鼠标句柄 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a848d8b2ee3267758e9a784be75b65e46" name="a848d8b2ee3267758e9a784be75b65e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848d8b2ee3267758e9a784be75b65e46">&#9670;&#160;</a></span>SetCursor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::SetCursor </td>
          <td>(</td>
          <td class="paramtype">StandardCursor&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>设置鼠标样式 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>鼠标样式 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad685138138402ddd8a5fde67bbb85a45" name="ad685138138402ddd8a5fde67bbb85a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad685138138402ddd8a5fde67bbb85a45">&#9670;&#160;</a></span>SetParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sw::UIElement::SetParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsw_1_1WndBase.html">WndBase</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置父窗口 </p>
<dl class="section return"><dt>返回</dt><dd>设置是否成功 </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#a5fd142cef45421381b2e8b89cac67d86">sw::WndBase</a> .</p>

</div>
</div>
<a id="a09acdba6221e69b6ecb17b49975a1414" name="a09acdba6221e69b6ecb17b49975a1414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09acdba6221e69b6ecb17b49975a1414">&#9670;&#160;</a></span>SetTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::SetTag </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置Tag </p>

<p>实现了 <a class="el" href="classsw_1_1ITag.html#a814b2084a60df545ba5d47e96f7928d3">sw::ITag</a>.</p>

</div>
</div>
<a id="ab8557638ba9975346d62f5339de55664" name="ab8557638ba9975346d62f5339de55664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8557638ba9975346d62f5339de55664">&#9670;&#160;</a></span>SetTextColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::SetTextColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsw_1_1Color.html">Color</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>redraw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置文本颜色 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>要设置的颜色 </td></tr>
    <tr><td class="paramname">redraw</td><td>是否重绘 </td></tr>
  </table>
  </dd>
</dl>

<p>被 <a class="el" href="classsw_1_1GroupBox.html#a6744ce46841a0348494df0ae9f4e56fb">sw::GroupBox</a>, <a class="el" href="classsw_1_1ListView.html#acb06dc6710aafdb341e75fd92fc08af1">sw::ListView</a>, <a class="el" href="classsw_1_1MonthCalendar.html#ac735773615992feb4f3394a7d361a8c1">sw::MonthCalendar</a> , 以及 <a class="el" href="classsw_1_1TreeView.html#aa336eb600d807ec06ca5fd5e335242e4">sw::TreeView</a> 重载.</p>

</div>
</div>
<a id="a6cf5a64206d296adf153e4d48db9e4ed" name="a6cf5a64206d296adf153e4d48db9e4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf5a64206d296adf153e4d48db9e4ed">&#9670;&#160;</a></span>ShowContextMenu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sw::UIElement::ShowContextMenu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsw_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sw::HorizontalAlignment&#160;</td>
          <td class="paramname"><em>horz</em> = <code>sw::HorizontalAlignment::Left</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sw::VerticalAlignment&#160;</td>
          <td class="paramname"><em>vert</em> = <code>sw::VerticalAlignment::Top</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>弹出当前元素的上下文菜单 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>弹出菜单在屏幕中的位置 </td></tr>
    <tr><td class="paramname">horz</td><td>菜单的水平方向对齐方式 </td></tr>
    <tr><td class="paramname">vert</td><td>菜单的垂直方向对齐方式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>若函数成功则返回true，否则返回false </dd></dl>

</div>
</div>
<a id="a56ab87f8a258e25ae429dab03771b5b4" name="a56ab87f8a258e25ae429dab03771b5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ab87f8a258e25ae429dab03771b5b4">&#9670;&#160;</a></span>ToUIElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsw_1_1UIElement.html">UIElement</a> * sw::UIElement::ToUIElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>尝试将对象转换成UIElement </p>
<dl class="section return"><dt>返回</dt><dd>若函数成功则返回UIElement指针，否则返回nullptr </dd></dl>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#ac04608233daebea10a3f0aa37c02b36d">sw::WndBase</a> .</p>

</div>
</div>
<a id="a0cbfb44f8280a3e5e01b71906e588d69" name="a0cbfb44f8280a3e5e01b71906e588d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbfb44f8280a3e5e01b71906e588d69">&#9670;&#160;</a></span>UnregisterRoutedEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sw::UIElement::UnregisterRoutedEvent </td>
          <td>(</td>
          <td class="paramtype">RoutedEventType&#160;</td>
          <td class="paramname"><em>eventType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>取消对应类型路由事件的注册，该函数会移除对应事件所有的处理函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventType</td><td>路由事件类型 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98812949329f77e400f7e0e381c56c3d" name="a98812949329f77e400f7e0e381c56c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98812949329f77e400f7e0e381c56c3d">&#9670;&#160;</a></span>VisibleChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sw::UIElement::VisibleChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newVisible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Visible属性改变时调用此函数 </p>

<p>重载 <a class="el" href="classsw_1_1WndBase.html#aef02bbac8ef450e5f3f478b41031a3ab">sw::WndBase</a> .</p>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="ab1ae9ea6fdb1c1ecde418bffdb2287cc" name="ab1ae9ea6fdb1c1ecde418bffdb2287cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ae9ea6fdb1c1ecde418bffdb2287cc">&#9670;&#160;</a></span>LayoutUpdateCondition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsw_1_1Property.html">Property</a>&lt;sw::LayoutUpdateCondition&gt; sw::UIElement::LayoutUpdateCondition</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>触发布局更新的条件 </p>
<dl class="section note"><dt>注解</dt><dd>修改该属性不会立即触发布局更新 </dd></dl>

</div>
</div>
<a id="a5fb0d213e16e64b9284bcbad8b038ab8" name="a5fb0d213e16e64b9284bcbad8b038ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb0d213e16e64b9284bcbad8b038ab8">&#9670;&#160;</a></span>LogicalRect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsw_1_1ReadOnlyProperty.html">ReadOnlyProperty</a>&lt;<a class="el" href="structsw_1_1Rect.html">sw::Rect</a>&gt; sw::UIElement::LogicalRect</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>元素的逻辑位置和尺寸，即去除布局偏移以及拉伸影响的位置和尺寸 </p>
<dl class="section note"><dt>注解</dt><dd>当布局未完成时该属性的值可能不准确 </dd></dl>

</div>
</div>
<a id="aa9d544a538ca2cfa3d022da61e7637e5" name="aa9d544a538ca2cfa3d022da61e7637e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d544a538ca2cfa3d022da61e7637e5">&#9670;&#160;</a></span>Transparent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsw_1_1Property.html">Property</a>&lt;bool&gt; sw::UIElement::Transparent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>是否使用透明背景 </p>
<dl class="section note"><dt>注解</dt><dd>此属性并非真正意义上的透明，将该属性设为true可继承父元素的背景颜色 </dd></dl>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li><a class="el" href="UIElement_8h_source.html">UIElement.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>sw</b></li><li class="navelem"><a class="el" href="classsw_1_1UIElement.html">UIElement</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
